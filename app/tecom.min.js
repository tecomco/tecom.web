"use strict";

angular.module("config", []).constant("ENV", {
    name: "dev",
    socketUri: "ws.localhost:8000"
});

var app = angular.module("tecomApp", [ "ui.router", "ngStorage", "angular-jwt", "ui.bootstrap", "config", "ngFileUpload", "ngSanitize", "mwl.confirm", "ngMessages", "angular-web-notification", "ngProgress", "bm.uiTour"]);

app.config([ "$httpProvider", "jwtOptionsProvider", "$localStorageProvider", function($httpProvider, jwtOptionsProvider, $localStorageProvider) {
    jwtOptionsProvider.config({
        tokenGetter: function() {
            return $localStorageProvider.get("token");
        }
    }), $httpProvider.interceptors.push("jwtInterceptor");
} ]), app.config([ "$httpProvider", "jwtInterceptorProvider", function($httpProvider, jwtInterceptorProvider) {
    jwtInterceptorProvider.authPrefix = "JWT ";
} ]), app.config([ "TourConfigProvider", function(TourConfigProvider) {
    TourConfigProvider.set("scrollIntoView", !1), TourConfigProvider.set("backdropBorderRadius", 5),
    TourConfigProvider.set("useHotkeys", !0);
} ]), app.run([ "$rootScope", "$timeout", function($rootScope, $timeout) {
    $rootScope.isLoading = !0, $rootScope.socketConnected = !0, $rootScope.hasUnread = !1,
    $rootScope.isLoadingTakingTooLong = !1, $timeout(function() {
        $rootScope.isLoadingTakingTooLong = !0;
    }, 1e4);
} ]), app.config([ "$locationProvider", function($locationProvider) {
    $locationProvider.html5Mode(!0);
} ]), app.config(function($stateProvider, $urlRouterProvider) {
    $urlRouterProvider.otherwise("/messenger/"), $stateProvider.state("messenger", {
        abstract: !0,
        url: "/messenger",
        views: {
            "": {
                templateUrl: "app/components/messenger/messenger.view.html?v=1.0.6"
            },
            "channels@messenger": {
                templateUrl: "app/components/messenger/channels/channels.view.html?v=1.0.6"
            }
        }
    }).state("messenger.home", {
        url: "/",
        template: '<div ng-controller="messagesController" class="msg-landing"><img src="static/img/tecom-bw.png" class="img-responsive" tour-step tour-step-content="سلام. به تیکام خوش اومدی! خوشحال می‌شم یه توضیح کوتاه بهت بدم... (۱/۸)" tour-step-order="0" tour-step-placement="right" /><h1>لطفا یک گروه را انتخاب کنید.</h1></div>'
    }).state("messenger.messages", {
        url: "/:slug",
        views: {
            "": {
                templateUrl: "app/components/messenger/messages/messages.view.html?v=1.0.8"
            },
            "header@messenger.messages": {
                templateUrl: "app/components/messenger/header/header.view.html?v=1.0.4"
            },
            "files@messenger.messages": {
                templateUrl: "app/components/files/files.view.html?v=1.0.6"
            },
            "filemanager@messenger.messages": {
                templateUrl: "app/components/files/filemanager-files.view.html?v=1.0.0"
            }
        },
        params: {
            slug: null
        }
    });
}), app.factory("File", [ "$window", "Line", "fileUtil", "$timeout", function($window, Line, fileUtil, $timeout) {
    function File(id, url, fileData, name, channelId) {
        this.id = id, this.url = url, this.name = name, this.channelId = channelId, this.lines = getLinesByData(fileData, this),
        this.isTempSelected = !1, this.isPermSelected = !1;
    }
    function getLinesByData(fileData, file) {
        var lines = [], prettifiedFile = $window.PR.prettyPrintOne(fileData, "", !0), el = document.createElement("html");
        el.innerHTML = prettifiedFile;
        for (var listItems = el.getElementsByTagName("li"), i = 0; i < listItems.length; i++) {
            var listItem = listItems[i], line = new Line(i + 1, listItem.innerHTML, file);
            lines.push(line);
        }
        return lines;
    }
    return File.prototype.selectTempLines = function(type, lineNum) {
        this.isTempSelected = !0, "start" === type ? this.tempStartLine = lineNum : "end" === type && (this.tempEndLine = lineNum);
    }, File.prototype.deselectTempLines = function() {
        this.isTempSelected = !1, this.tempStartLine = null, this.tempEndLine = null;
    }, File.prototype.selectPermLines = function(startLine, endLine) {
        this.isPermSelected = !0, this.permStartLine = startLine, this.permEndLine = endLine;
        var that = this;
        this.permTimeout && $timeout.cancel(this.permTimeout), this.permTimeout = $timeout(function() {
            that.isPermSelected = !1;
        }, 2e3);
    }, File.prototype.getLine = function(lineNum) {
        return this.lines[lineNum - 1];
    }, File.prototype.getTempLines = function() {
        return this.isTempSelected ? this.findStartAndEndTempLines(this) : null;
    }, File.prototype.findStartAndEndTempLines = function() {
        return {
            start: Math.min(this.tempStartLine, this.tempEndLine),
            end: Math.max(this.tempStartLine, this.tempEndLine)
        };
    }, File.prototype.isLineTemp = function(lineNumber) {
        if (this.isTempSelected) {
            var tempLines = this.findStartAndEndTempLines();
            return lineNumber >= tempLines.start && lineNumber <= tempLines.end;
        }
        return !1;
    }, File;
} ]), app.factory("Line", [ function() {
    function Line(number, html, file) {
        this.num = number, this.html = html, this.file = file;
    }
    return Line.prototype.getCssClass = function() {
        if (this.file.isTempSelected) {
            if (this.num >= this.file.tempStartLine && this.num <= this.file.tempEndLine) return "line-temp-selected";
        } else if (this.file.isPermSelected && this.num >= this.file.permStartLine && this.num <= this.file.permEndLine) return "line-perm-selected";
    }, Line.SELECT_TYPE = {
        TEMPORARY: 0,
        PERMENANT: 1
    }, Line;
} ]), app.factory("FileManagerFile", [ "dateUtil", "fileUtil", function(dateUtil, fileUtil) {
    function FileManagerFile(id, url, name, date, type) {
        this.id = id, this.url = url, this.name = name, this.date = new Date(date), this.extension = type,
        this.type = this.getFileType(), this.svg = this.getSvgUrl();
    }
    return FileManagerFile.prototype.getSvgUrl = function() {
        return "/static/img/file-formats.svg#" + this.extension;
    }, FileManagerFile.prototype.getFileName = function() {
        return this.name.replace("." + this.extension, "");
    }, FileManagerFile.prototype.canBeLived = function() {
        return fileUtil.isTextFormat(this.extension);
    }, FileManagerFile.prototype.isPhoto = function() {
        return fileUtil.isPictureFormat(this.extension);
    }, FileManagerFile.prototype.getLocalDate = function() {
        return dateUtil.getPersianDateString(this.date);
    }, FileManagerFile.prototype.getFileType = function() {
        return fileUtil.fileManagerFileFormat(this.extension);
    }, FileManagerFile.prototype.downloadFile = function() {
        var link = document.createElement("a");
        link.download = this.name, link.href = this.url, link.click();
    }, FileManagerFile.TYPE = {
        CODE: 1,
        PICTURE: 2,
        DOCUMENT: 3,
        OTHER: 4
    }, FileManagerFile;
} ]), app.controller("fileManagerController", [ "$scope", "filesService", "channelsService", "FileManagerFile", "$state", "Fullscreen", function($scope, filesService, channelsService, FileManagerFile, $state, Fullscreen) {
    $scope.files = [], $scope.fileManagerFilterType = null;
    var isLoading = !1, isFileManagerClosed = !0, isFileManagerInitialized = !0;
    $scope.$on("channel:changed", function() {
        $scope.channel = channelsService.getCurrentChannel();
    }), $scope.$on("file:newFileManagerFile", function(event, file) {
        $scope.files.push(file);
    }), $scope.getFileManagerClass = function() {
        return isFileManagerClosed ? "mime-holder closed" : "mime-holder opened";
    }, $scope.toggleFileManagerStatus = function() {
        isFileManagerInitialized ? (isLoading = !0, filesService.getFileManagerFiles($scope.channel.id).then(function(files) {
            $scope.files = files, isFileManagerInitialized = !1, isLoading = !1, isFileManagerClosed = !1;
        })) : isFileManagerClosed = !isFileManagerClosed;
    }, $scope.getFileManagerToggleClass = function() {
        return isLoading ? "fa fa-spinner" : "mime-menu-toggle";
    }, $scope.doesChannelHaveAnyFilteredFiles = function() {
        return null === $scope.fileManagerFilterType ? 0 !== $scope.files.length : 0 !== $scope.files.filter(function(file) {
            return file.type === $scope.fileManagerFilterType;
        }).length;
    }, $scope.shouldShowInFileManager = function(file) {
        return !$scope.fileManagerFilterType || $scope.fileManagerFilterType === file.type;
    }, $scope.getMessageOfNoFilteredFile = function() {
        switch (parseInt($scope.fileManagerFilterType)) {
          case null:
            return "هیچ فایلی وجود ندارد";

          case FileManagerFile.TYPE.CODE:
            return "هیچ فایلی به صورت کد وحود ندارد";

          case FileManagerFile.TYPE.PICTURE:
            return "هیچ عکسی وجود ندارد";

          case FileManagerFile.TYPE.DOCUMENT:
            return "هیچ سندی وجود ندارد";

          case FileManagerFile.TYPE.OTHER:
            return "هیچ فایل دیگری وحود ندارد";
        }
    }, $scope.goLive = function(fileId, fileName) {
        filesService.makeFileLive($scope.channel.id, fileId, fileName);
    }, $scope.viewFile = function(fileId) {
        filesService.viewFile(fileId);
    }, $scope.fullscreenPhoto = function(id) {
        var photoId = "img-" + id;
        Fullscreen.enable(document.getElementById(photoId));
    }, $scope.navigateToHome = function() {
        $state.go("messenger.home");
    };
} ]), app.controller("filesController", [ "$window", "filesService", "Upload", "$scope", "$timeout", "$rootScope", function($window, filesService, Upload, $scope, $timeout, $rootScope) {
    function broadcastViewState() {
        $rootScope.$broadcast("view:state:changed", $scope.viewState());
    }
    function scrollToLine(file, start, end) {
        var codeView;
        codeView = "live" === $scope.viewState() ? document.getElementById("liveCodeView") : document.getElementById("codeView"),
        $timeout(function() {
            var middleLine;
            middleLine = Math.abs(start, end) < 30 ? Math.ceil((start + end) / 2) : start;
            var middle = (middleLine - 17) / file.lines.length * codeView.scrollHeight;
            codeView.scrollTop = middle;
        }, 0, !1);
    }
    $scope.vm = {};
    var startLine, selectTextMode = !1, flagLineIsTemp = !1;
    $scope.fileLoading = !1, $scope.isViewedFileClicked = !1;
    var selectedFileType = "none";
    filesService.updateLiveFile(), $scope.$on("channel:ready", function(event, data) {
        $scope.channel = data;
    }), $scope.$on("file:loading", function() {
        $scope.fileLoading = !0;
    });
    var self = this;
    $scope.$on("file:ready", function() {
        $scope.fileLoading = !1;
    }), $scope.$on("channels:updated", function(event, data) {
        "init" === data && filesService.updateLiveFile();
    }), $scope.$on("file:lived", function(event, file) {
        selectedFileType = "live", $scope.vm.viewFile && file.id === $scope.vm.viewFile.id && ($scope.vm.viewFile = null),
        $scope.vm.liveFile = file, broadcastViewState();
    }), $scope.$on("file:killed", function() {
        selectedFileType = "view", $scope.vm.liveFile = null, broadcastViewState();
    }), $scope.$on("file:view", function(event, file) {
        selectedFileType = "view", $scope.vm.viewFile = file, broadcastViewState();
    }), $scope.$on("file:show:line", function(event, file, startLine, endLine) {
        file === $scope.vm.liveFile ? (selectedFileType = "live", file.selectPermLines(startLine, endLine),
        scrollToLine(file, startLine, endLine)) : file === $scope.vm.viewFile ? (selectedFileType = "view",
        file.selectPermLines(startLine, endLine), scrollToLine(file, startLine, endLine)) : (selectedFileType = "view",
        openFile(file), file.selectPermLines(startLine, endLine), scrollToLine(file, startLine, endLine)),
        broadcastViewState();
    }), $scope.$on("file:upload", function(event, file, errFiles) {
        file && $rootScope.$broadcast("file:uploading", file), !file && errFiles[0] && $rootScope.$broadcast("file:uploadError");
    }), $scope.showViewedFileClickedWarning = function() {
        self.viewClickTimeout && $timeout.cancel(self.viewClickTimeout), $scope.viewClickNotif || ($scope.viewClickNotif = !0),
        self.viewClickTimeout = $timeout(function() {
            $scope.viewClickNotif = !1;
        }, 3e3);
    }, $scope.mouseDownLine = function(lineNum) {
        selectTextMode = !0, $scope.vm.liveFile.isLineTemp(lineNum) && (flagLineIsTemp = !0,
        $scope.vm.liveFile.deselectTempLines()), startLine = lineNum, $scope.vm.liveFile.selectTempLines("start", lineNum),
        $scope.vm.liveFile.selectTempLines("end", lineNum);
    }, $scope.mouseUpLine = function(lineNum) {
        flagLineIsTemp && startLine === lineNum && ($scope.vm.liveFile.deselectTempLines(),
        flagLineIsTemp = !1), selectTextMode = !1, document.getElementById("inputPlaceHolder").focus();
    }, $scope.mouseOverLine = function(lineNum) {
        if (selectTextMode) {
            var start = Math.min(startLine, lineNum), end = Math.max(startLine, lineNum);
            $scope.vm.liveFile.selectTempLines("start", start), $scope.vm.liveFile.selectTempLines("end", end);
        }
    };
    var openFile = function(file) {
        filesService.viewFile(file.id, file.name);
    };
    $scope.closeLiveFile = function() {
        $scope.vm.liveFile.deselectTempLines(), filesService.killLiveFile($scope.vm.liveFile),
        $scope.vm.liveFile = null, broadcastViewState();
    }, $scope.closeViewFile = function() {
        selectedFileType = "live", $scope.vm.viewFile = null, broadcastViewState();
    }, $scope.liveFileTabClick = function() {
        selectedFileType = "live", broadcastViewState();
    }, $scope.viewFileTabClick = function() {
        selectedFileType = "view", broadcastViewState();
    }, $scope.viewState = function() {
        return $scope.vm.liveFile || $scope.vm.viewFile ? "live" === selectedFileType ? "live" : "view" : "noFile";
    }, $scope.upload = function(file, errFiles) {
        $rootScope.$broadcast("file:upload", file, errFiles);
    }, $scope.getFileDownloadData = function(type) {
        return "live" === $scope.viewState() && $scope.vm.liveFile ? "url" === type ? $scope.vm.liveFile.url : $scope.vm.liveFile.name : "view" === $scope.viewState() && $scope.vm.viewFile ? "url" === type ? $scope.vm.viewFile.url : $scope.vm.viewFile.name : void 0;
    }, $scope.makeViewFileLive = function() {
        var file = $scope.vm.viewFile;
        filesService.makeFileLive(file.channelId, file.id, file.name);
    }, broadcastViewState();
} ]), app.service("filesService", [ "$rootScope", "$http", "$log", "socket", "ArrayUtil", "$q", "channelsService", "File", "FileManagerFile", "fileUtil", "Upload", function($rootScope, $http, $log, socket, ArrayUtil, $q, channelsService, File, FileManagerFile, fileUtil, Upload) {
    function updateLiveFile() {
        var currentChannel = channelsService.getCurrentChannel();
        currentChannel && (currentChannel.liveFileId ? getFileById(currentChannel.liveFileId).then(function(file) {
            $rootScope.$broadcast("file:lived", file), self.livedFile = file;
        }) : (self.livedFile = null, $rootScope.$broadcast("file:killed")));
    }
    function getFileDataByUrl(fileUrl) {
        return $http({
            method: "GET",
            url: fileUrl
        });
    }
    function getFileById(fileId) {
        var defer = $q.defer(), file = ArrayUtil.getElementByKeyValue(self.files, "id", fileId);
        if (file) defer.resolve(file); else {
            $rootScope.$broadcast("file:loading");
            var url, name, type, channelId;
            $http({
                method: "GET",
                url: "/api/v1/files/" + fileId + "/"
            }).then(function(res) {
                return url = res.data.file, name = res.data.name, type = res.data.type, channelId = res.data.channel,
                getFileDataByUrl(url);
            }).then(function(res) {
                if (fileUtil.isTextFormat(type)) {
                    var file = new File(fileId, url, res.data, name, channelId);
                    self.files.push(file), $rootScope.$broadcast("file:ready"), defer.resolve(file);
                } else $log.error("Lived File Format Not Supported Yet !"), $rootScope.$broadcast("file:ready"),
                defer.reject();
            }).catch(function(err) {
                $log.error("Error Getting File name and URL From Server.", err), $rootScope.$broadcast("file:ready"),
                defer.reject();
            });
        }
        return defer.promise;
    }
    function uploadFile(fileName, channelId, memberId, fileData, message) {
        var deferred = $q.defer();
        return uploadQueue.push({
            fileName: fileName,
            channelId: channelId,
            memberId: memberId,
            fileData: fileData,
            message: message,
            deferred: deferred
        }), 1 === uploadQueue.length && upload(), deferred.promise;
    }
    function upload() {
        var fileData = uploadQueue[0];
        Upload.upload({
            url: "api/v1/files/upload/" + fileData.fileName,
            data: {
                name: fileData.fileName,
                channel: fileData.channelId,
                sender: fileData.memberId,
                file: fileData.fileData
            },
            method: "PUT"
        }).then(function(res) {
            fileData.deferred.resolve(res);
        }, function(resp) {
            $log.error("Error status: " + resp.status), fileData.deferred.reject();
        }, function(evt) {
            var percent = parseInt(100 * evt.loaded / evt.total);
            100 === percent ? fileData.message.uploadProgressBar.complete() : fileData.message.uploadProgressBar.set(percent);
        }).finally(function() {
            uploadQueue.shift(), uploadQueue.length > 0 && upload();
        });
    }
    function getFileManagerFiles(channelId) {
        var deferred = $q.defer();
        return $http({
            method: "GET",
            url: "/api/v1/files/channels/" + channelId + "/"
        }).then(function(filesData) {
            var files = filesData.data.map(function(file) {
                return new FileManagerFile(file.id, file.file, file.name, file.date_uploaded, file.type);
            });
            deferred.resolve(files);
        }).catch(function(err) {
            $log.info("Error Getting FileManager Files.", err), deferred.reject(err);
        }), deferred.promise;
    }
    function viewFile(fileId) {
        self.livedFile && self.livedFile.id === fileId ? updateLiveFile() : getFileById(fileId).then(function(file) {
            $rootScope.$broadcast("file:view", file);
        });
    }
    function makeFileLive(channelId, fileId, fileName) {
        sendLiveFileDataToServer("makeLive", channelId, fileName, fileId);
    }
    function killLiveFile(file) {
        sendLiveFileDataToServer("kill", file.channelId, file.name);
    }
    function sendLiveFileDataToServer(type, channelId, fileName, fileId) {
        var data = {
            channelId: channelId,
            fileName: fileName
        };
        "makeLive" === type ? data.fileId = fileId : "kill" === type && (data.fileId = null),
        socket.emit("file:lived", data);
    }
    function getLivedFile() {
        return self.livedFile;
    }
    function createFileManagerFile(id, url, name, date, type) {
        var file = new FileManagerFile(id, file, name, date, type);
        $rootScope.$broadcast("file:newFileManagerFile", file);
    }
    function showFileLine(fileId, startLine, endLine) {
        getFileById(fileId).then(function(file) {
            $rootScope.$broadcast("file:show:line", file, startLine, endLine);
        });
    }
    var self = this, uploadQueue = [];
    return self.files = [], self.viewFile = null, socket.on("file:lived", function(data) {
        channelsService.setChannelLivedFileId(data.channelId, data.fileId), updateLiveFile();
    }), {
        makeFileLive: makeFileLive,
        killLiveFile: killLiveFile,
        updateLiveFile: updateLiveFile,
        getLivedFile: getLivedFile,
        showFileLine: showFileLine,
        getFileById: getFileById,
        uploadFile: uploadFile,
        getFileManagerFiles: getFileManagerFiles,
        viewFile: viewFile,
        createFileManagerFile: createFileManagerFile
    };
} ]);

var app = angular.module("LoginApp", [ "ui.router", "ngStorage", "angular-jwt", "ismobile" ]).config([ "$locationProvider", function($locationProvider) {
    $locationProvider.html5Mode(!0);
} ]).config([ "$stateProvider", "$urlRouterProvider", "isMobileProvider", function($stateProvider, $urlRouterProvider, isMobile) {
    $urlRouterProvider.otherwise("/login"), $stateProvider.state("login", {
        url: "/login",
        views: {
            "": {
                templateUrl: "app/components/login/login-form.html?v=1.0.3"
            }
        },
        onEnter: function($window) {
            if (isMobile.phone) {
                var mobileType;
                mobileType = isMobile.apple.phone ? "iOS" : isMobile.android.phone ? "Android" : "Mobile",
                $window.location.assign("/mobile?os=" + mobileType);
            }
        }
    });
} ]).controller("loginController", [ "$scope", "$log", "$window", "$location", "$http", "$localStorage", "AuthService", function($scope, $log, $window, $location, $http, $localStorage, AuthService) {
    $scope.hasLoginError = !1, $scope.submitClicked = !1, $scope.isLoading = !1, $scope.passwordRecoveryUrl = function() {
        var splitHost = $window.location.host.split("."), domain = splitHost[1];
        return "http://" + (domain += splitHost[2] ? "." + splitHost[2] : "") + "/password/recovery/";
    }(), $scope.redirectError = function() {
        switch ($location.search().err) {
          case "InvalidToken":
            return "متاسفانه محتوای Token شما نامعتبر است، لطفا دوباره وارد شوید.";

          case "UserRemoved":
            return "شما توسط یکی از ادمین‌ها از تیم حذف شدید!";

          default:
            return null;
        }
    }(), function() {
        var token = $location.search().token;
        token && ($localStorage.token = token, $window.location.assign("/messenger"));
    }(), $scope.login = function() {
        $scope.forms.login.email.$valid && $scope.forms.login.password.$valid && ($scope.isLoading = !0,
        AuthService.login($scope.email, $scope.password).then(function() {
            $window.location.assign("/messenger");
        }).catch(function(err) {
            $scope.isLoading = !1, $log.error("Login Error:", err), $scope.hasloginError = !1,
            err.data && ($scope.hasLoginError = !0, "object" == typeof err.data && "User does not belong to team." === err.data[0] ? $scope.loginErrorString = "شما در این تیم عضو نیستید." : "object" == typeof err.data.non_field_errors && "Unable to log in with provided credentials." === err.data.non_field_errors[0] ? $scope.loginErrorString = "نام کاربری یا رمزعبور صحیح نمی باشد." : $scope.loginErrorString = "خطا در اتصال به سرور"),
            initializeLoginForm();
        }));
    }, angular.element(document).ready(function() {
        initializeLoginForm();
    });
    var initializeLoginForm = function() {
        $scope.forms.login.$setPristine(), $scope.password = "";
    };
} ]);

app.controller("createChannelController", [ "$scope", "$uibModalInstance", "$log", "channelsService", "Channel", "ArrayUtil", "CurrentMember", "Team", function($scope, $uibModalInstance, $log, channelsService, Channel, ArrayUtil, CurrentMember, Team) {
    function makeTeamMembersArray() {
        Team.getActiveMembers().forEach(function(member) {
            $scope.teamMembers.push(member), member.selected = !1;
        }), ArrayUtil.removeElementByKeyValue($scope.teamMembers, "id", CurrentMember.member.id);
    }
    $scope.forms = {}, $scope.newChannel = {}, $scope.teamMembers = [];
    var selectedMembers = [], makeSelectedMembersArray = function() {
        selectedMembers = [], selectedMembers.push(CurrentMember.member.id.toString());
        for (var i = 0; i < $scope.teamMembers.length; i++) !0 === $scope.teamMembers[i].selected && selectedMembers.push($scope.teamMembers[i].id.toString());
    };
    $scope.formNameCheckEmpty = function(form) {
        return (form.name.$touched || form.$submitted) && !form.name.$viewValue;
    }, $scope.formNameCheckMax = function(form) {
        return form.name.$viewValue && form.name.$invalid;
    }, $scope.closeCreateChannel = function() {
        $uibModalInstance.close();
    }, $scope.createChannelSubmit = function() {
        $scope.newChannel.serverError = !1, !0 === $scope.forms.newChannelForm.$valid && sendNewChannelData();
    }, $scope.teamMemberClick = function(teamMember) {
        teamMember.selected = !teamMember.selected;
    }, $scope.getCssClass = function(teamMember) {
        return teamMember.selected ? "selected" : "selectable";
    };
    var sendNewChannelData = function() {
        makeSelectedMembersArray();
        var newChannelType = $scope.newChannel.isPrivate ? Channel.TYPE.PRIVATE : Channel.TYPE.PUBLIC, newChannelData = {
            name: $scope.newChannel.name,
            description: $scope.newChannel.description,
            type: newChannelType,
            member_ids: selectedMembers,
            creator: CurrentMember.member.id,
            team: Team.id
        };
        channelsService.createChannel(newChannelData).then(function() {
            $scope.closeCreateChannel();
        }).catch(function(err) {
            -1 != err.indexOf("Duplicate slug in team.") ? ($log.error("Error Creating new Channel:", err),
            $scope.newChannel.dublicateError = !0) : $scope.newChannel.serverError = !0;
        });
    };
    angular.element(document).ready(function() {
        initializeNewChannelForm();
    });
    var initializeNewChannelForm = function() {
        $scope.newChannel.name = "", $scope.newChannel.description = "", $scope.newChannel.isPrivate = !1,
        $scope.newChannel.dublicateError = !1, $scope.newChannel.serverError = !1, $scope.forms.newChannelForm.$setPristine(),
        makeTeamMembersArray();
    };
} ]), app.controller("channelDetailsController", [ "$scope", "$uibModalInstance", "$log", "channelsService", "ArrayUtil", "Channel", "ChannelMemberItem", "CurrentMember", "Team", function($scope, $uibModalInstance, $log, channelsService, ArrayUtil, Channel, ChannelMemberItem, CurrentMember, Team) {
    function setDetailsFormDatas() {
        $scope.details.name = channelData.name, $scope.details.description = channelData.description,
        $scope.details.isPrivate = channelData.type === Channel.TYPE.PRIVATE, clearCustomErrorMessages();
    }
    function addActiveTeamMembersTochannelMemberItems() {
        Team.getActiveMembers().forEach(function(teamMember) {
            var item = new ChannelMemberItem(teamMember.id);
            $scope.channelMemberItems.push(item);
        });
    }
    function getChannelMembersAndAddTochannelMemberItems() {
        channelsService.getChannelMembers($scope.channel.id).then(function(res) {
            res && res.data && res.data.forEach(function(channelMember) {
                var item = findChanneMemberItemById(channelMember.member);
                item && item.setChannelMemberId(channelMember.id);
            });
        });
    }
    function findChanneMemberItemById(id) {
        return ArrayUtil.getElementByKeyValue($scope.channelMemberItems, "teamMemberId", id);
    }
    function sendAddedMemberIdsToServer(teamMemberIds) {
        channelsService.addMembersToChannel(teamMemberIds, $scope.channel.id).then(function(channelMembersData) {
            setAddedMembersChannelIds(channelMembersData);
        }).catch(function() {
            $scope.serverError = !0, removeTemporaryChannelMembers();
        });
    }
    function setAddedMembersChannelIds(channelMembersData) {
        channelMembersData.forEach(function(data) {
            ArrayUtil.getElementByKeyValue($scope.channelMemberItems, "teamMemberId", data.member).setChannelMemberId(data.id);
        });
    }
    function removeTemporaryChannelMembers() {
        $scope.channelMemberItems.forEach(function(channelMember) {
            channelMember.removeFromTemporary();
        });
    }
    function unselectAllChannelMemberItems() {
        $scope.channelMemberItems.forEach(function(item) {
            item.isSelected = !1;
        });
    }
    function clearCustomErrorMessages() {
        $scope.serverError = !1, $scope.forms.detailsForm.name.$error.duplicate = !1;
    }
    $scope.editMode = !1, $scope.addMemberMode = !1, $scope.channel = channelsService.getCurrentChannel(),
    $scope.isMuted = $scope.channel.isMuted, $scope.isAdmin = CurrentMember.member.isAdmin,
    $scope.details = {}, $scope.forms = {}, $scope.serverError = !1, $scope.channelMemberItems = [];
    var channelData;
    $scope.editChannelClick = function() {
        $scope.editMode = !0, $scope.serverError = !1, channelData = channelsService.getCurrentChannel().getChannelData(),
        setDetailsFormDatas();
    }, $scope.submitChannelDetailsForm = function() {
        clearCustomErrorMessages(), $scope.forms.detailsForm.$setPristine();
        var type = $scope.details.isPrivate ? Channel.TYPE.PRIVATE : Channel.TYPE.PUBLIC, editedData = {
            name: $scope.details.name,
            description: $scope.details.description,
            type: type,
            id: $scope.channel.id
        };
        channelsService.sendEditedChannel(editedData).then(function() {
            clearCustomErrorMessages(), $scope.editMode = !1, $log.info("Done Editing Channel");
        }).catch(function(message) {
            -1 != message.indexOf("Duplicate slug in team.") ? ($scope.forms.detailsForm.name.$error.duplicate = !0,
            $log.error("Error : Dublicate Slug")) : ($scope.serverError = !0, $log.error("Error sending new channel form to server :", message));
        });
    }, angular.element(document).ready(function() {
        initializeDetailsForm();
    });
    var initializeDetailsForm = function() {
        $scope.details.duplicateError = !1, $scope.forms.detailsForm.$setPristine(), $scope.forms.detailsForm.$submitted = !1,
        $scope.addedMemberIds = [], addActiveTeamMembersTochannelMemberItems(), getChannelMembersAndAddTochannelMemberItems();
    };
    $scope.toggleIsMuted = function() {
        $scope.channel.isMuted = $scope.isMuted, channelsService.toggleIsMuted($scope.channel.id);
    }, $scope.removeMember = function(channelMember) {
        var data = {
            channelMemberId: channelMember.channelMemberId,
            memberId: channelMember.teamMemberId,
            channelId: $scope.channel.id,
            channelType: $scope.channel.type
        };
        channelsService.removeMemberFromChannel(data).then(function() {
            channelMember.removeChannelMemberId(), $log.info("Member Removed from Channel");
        }).catch(function(message) {
            $log.error("Error Removing member from channel:", message);
        });
    }, $scope.addMembersClick = function() {
        $scope.addMemberMode = !0, clearCustomErrorMessages();
    }, $scope.submitAddedMembers = function() {
        clearCustomErrorMessages();
        var teamMemberIds = [];
        $scope.channelMemberItems.forEach(function(item) {
            item.isSelected && !item.isChannelMember() && (teamMemberIds.push(item.teamMemberId),
            item.setTemporaryInChannel());
        }), teamMemberIds.length > 0 && sendAddedMemberIdsToServer(teamMemberIds), $scope.addMemberMode = !1;
    }, $scope.isUserAdmin = function() {
        return CurrentMember.member.isAdmin;
    }, $scope.archiveChannel = function() {
        clearCustomErrorMessages(), channelsService.archiveChannel($scope.channel.id).then(function() {
            $scope.$close();
        }).catch(function() {
            $scope.serverError = !0;
        });
    }, $scope.cancelEditMode = function() {
        $scope.editMode = !1, setDetailsFormDatas(), clearCustomErrorMessages();
    }, $scope.cancelAddingMembers = function() {
        $scope.addMemberMode = !1, unselectAllChannelMemberItems(), clearCustomErrorMessages();
    };
} ]), app.factory("ChannelMemberItem", [ "CurrentMember", "Team", function(CurrentMember, Team) {
    function ChannelMemberItem(teamMemberId) {
        this.member = Team.getMemberByMemberId(teamMemberId), this.teamMemberId = this.member.id,
        this.username = this.member.user.username, this.isSelected = !1, this.temporaryInChannel = !1,
        this.channelMemberId = null;
    }
    return ChannelMemberItem.prototype.isChannelMember = function() {
        return !(!this.channelMemberId && !this.temporaryInChannel);
    }, ChannelMemberItem.prototype.setChannelMemberId = function(channelMemberId) {
        this.channelMemberId = channelMemberId, this.temporaryInChannel = !1;
    }, ChannelMemberItem.prototype.removeChannelMemberId = function() {
        this.channelMemberId = null, this.temporaryInChannel = !1, this.isSelected = !1;
    }, ChannelMemberItem.prototype.getCssClass = function(addMemberMode) {
        return addMemberMode ? this.isChannelMember() ? "disabled" : this.isSelected ? "selected" : "selectable" : "";
    }, ChannelMemberItem.prototype.click = function(addMemberMode) {
        addMemberMode && (this.isSelected = !this.isSelected);
    }, ChannelMemberItem.prototype.setTemporaryInChannel = function() {
        this.temporaryInChannel = !0;
    }, ChannelMemberItem.prototype.removeFromTemporary = function() {
        this.temporaryInChannel = !1;
    }, ChannelMemberItem;
} ]), app.factory("Channel", [ "$stateParams", "textUtil", "ArrayUtil", "$q", "CurrentMember", "Team", "Member", function($stateParams, textUtil, ArrayUtil, $q, CurrentMember, Team, Member) {
    function Channel(name, slug, description, type, id, membersCount, memberId, isFakeDirect, liveFileId, teamId, isCurrentMemberChannelMember, isMuted, lastSeenId, lastDatetime, lastMessageId, memberLastSeenId) {
        this.setValues(name, slug, description, type, id, membersCount, memberId, isFakeDirect, liveFileId, teamId, isCurrentMemberChannelMember, isMuted, lastSeenId, lastDatetime, lastMessageId, memberLastSeenId),
        this.isTypingMemberIds = [], this.hideNotifFunction = null, this.initialMessagesPromise = null;
    }
    return Channel.prototype.setValues = function(name, slug, description, type, id, membersCount, memberId, isFakeDirect, liveFileId, teamId, isCurrentMemberChannelMember, isMuted, lastSeenId, lastDatetime, lastMessageId, memberLastSeenId) {
        this.name = name, this.slug = slug, this.description = description, this.type = type,
        this.id = id, this.membersCount = membersCount, memberId && (this.member = Team.getMemberByMemberId(memberId)),
        this.isFakeDirect = isFakeDirect, this.liveFileId = liveFileId, this.teamId = teamId,
        this.active = !0, this.isCurrentMemberChannelMember = isCurrentMemberChannelMember,
        this.isMuted = isMuted, this.lastSeenId = lastSeenId, lastDatetime && (this.lastDatetime = new Date(lastDatetime)),
        this.lastMessageId = lastMessageId, this.memberLastSeenId = memberLastSeenId || 0;
    }, Channel.prototype.hasUnread = function() {
        return this.getNotifCount() && 0 !== this.getNotifCount();
    }, Channel.prototype.isCurrentMemberPublicChannelMember = function() {
        return !this.isPublic() || this.isCurrentMemberChannelMember;
    }, Channel.prototype.getDescription = function() {
        return this.description || "این گروه توضیحی ندارد.";
    }, Channel.prototype.shouldSendNotification = function() {
        return this.hideNotifFunction && (this.hideNotifFunction(), this.hideNotifFunction = null),
        this.isCurrentMemberPublicChannelMember() && CurrentMember.isDontDisturbModeDeactive() && !this.isMuted;
    }, Channel.prototype.updateFromJson = function(json) {
        this.name = json.name || null, this.slug = json.slug || null, this.description = json.description || null,
        this.type = json.type;
    }, Channel.prototype.getLocaleNotifCount = function() {
        return this.hasUnread() ? textUtil.persianify(this.getNotifCount().toString()) : null;
    }, Channel.prototype.getLocaleMembersCount = function() {
        return this.membersCount ? textUtil.persianify(this.membersCount.toString()) : null;
    }, Channel.prototype.setLastDatetime = function(datetime) {
        this.lastDatetime = datetime;
    }, Channel.prototype.setLastSeen = function(lastSeenMessageId) {
        this.lastSeenId = lastSeenMessageId;
    }, Channel.prototype.seenLastMessage = function() {
        this.lastMessageId++, this.memberLastSeenId++;
    }, Channel.prototype.areAllMessagesHaveBeenSeen = function(lastSeenMessageId) {
        return this.memberLastSeenId === this.lastMessageId;
    }, Channel.prototype.addIsTypingMemberId = function(memberId) {
        this.isTypingMemberIds.push(memberId);
    }, Channel.prototype.removeIsTypingMemberId = function(memberId) {
        ArrayUtil.removeElementByValue(this.isTypingMemberIds, memberId);
    }, Channel.prototype.getIsTypingString = function() {
        var isTypingStr = "";
        return angular.forEach(this.isTypingMemberIds, function(memberId) {
            isTypingStr += Team.getUsernameByMemberId(memberId), isTypingStr += " و ";
        }), isTypingStr.slice(0, isTypingStr.length - 3);
    }, Channel.prototype.anyoneTyping = function() {
        return this.isTypingMemberIds.length > 0;
    }, Channel.prototype.isSelected = function() {
        var slug = this.isDirect() ? "@" + this.slug : this.slug;
        return $stateParams.slug === slug;
    }, Channel.prototype.setInitialMessagesPromise = function(promise) {
        this.initialMessagesPromise = promise;
    }, Channel.prototype.getIconClass = function() {
        switch (this.type) {
          case Channel.TYPE.PUBLIC:
            return "fa fa-globe";

          case Channel.TYPE.PRIVATE:
            return "fa fa-lock";

          case Channel.TYPE.DIRECT:
            if (CurrentMember.member.isTecomBot()) return "zmdi zmdi-circle member-status status-offline";
            if (this.slug === Member.TECOM_BOT.username) return "fa fa-heart";
            switch (this.member.status) {
              case Member.STATUS.OFFLINE:
                return "zmdi zmdi-circle member-status status-offline";

              case Member.STATUS.ONLINE:
                return "zmdi zmdi-circle member-status status-online";

              case Member.STATUS.DEACTIVE:
                return "zmdi zmdi-circle member-status status-deactive";
            }
        }
    }, Channel.prototype.getDirectStatus = function() {
        if (CurrentMember.member.isTecomBot()) return "آفلاین";
        if (this.slug === Member.TECOM_BOT.username) return "همیشه آنلاین";
        switch (this.member.status) {
          case Member.STATUS.OFFLINE:
            return "آفلاین";

          case Member.STATUS.ONLINE:
            return "آنلاین";

          case Member.STATUS.DEACTIVE:
            return "حذف شده از تیم";
        }
    }, Channel.prototype.getNotifCountClass = function() {
        return this.isCurrentMemberChannelMember ? "badge" : "badge badge-grey";
    }, Channel.prototype.getNotifCount = function() {
        return this.memberLastSeenId ? this.lastMessageId - this.memberLastSeenId : this.lastMessageId;
    }, Channel.prototype.getCssClass = function() {
        return this.isSelected() ? "active" : "";
    }, Channel.prototype.isPrivate = function() {
        return this.type === Channel.TYPE.PRIVATE;
    }, Channel.prototype.isDirect = function() {
        return this.type === Channel.TYPE.DIRECT;
    }, Channel.prototype.isPublic = function() {
        return this.type === Channel.TYPE.PUBLIC;
    }, Channel.prototype.canMemberSendMessage = function() {
        return !this.getIsRemoved() && !this.getIsArchived() && this.active && this.isCurrentMemberPublicChannelMember();
    }, Channel.prototype.changeNameAndSlugFromId = function() {
        var that = this, ids = [];
        ids.push(parseInt(this.slug.slice(0, this.slug.indexOf(":")))), ids.push(parseInt(this.slug.slice(this.slug.indexOf(":") + 1, this.slug.length))),
        ids.forEach(function(id) {
            id !== CurrentMember.member.id && that.setNameAndSlugById(id);
        });
    }, Channel.prototype.setNameAndSlugById = function(id) {
        var name = Team.getUsernameByMemberId(id);
        this.name = name, this.slug = name;
    }, Channel.prototype.getChannelData = function() {
        return {
            name: this.name,
            description: this.description,
            type: this.type
        };
    }, Channel.prototype.getUrlifiedSlug = function() {
        return this.isDirect() ? "@" + this.slug : this.slug;
    }, Channel.prototype.setIsRemoved = function() {
        this.isRemoved = !0, this.isCurrentMemberChannelMember = !1;
    }, Channel.prototype.getIsRemoved = function() {
        return this.isRemoved || !1;
    }, Channel.prototype.setIsArchived = function() {
        this.isArchived = !0;
    }, Channel.prototype.getIsArchived = function() {
        return this.isArchived || !1;
    }, Channel.TYPE = {
        PUBLIC: 0,
        PRIVATE: 1,
        DIRECT: 2
    }, Channel;
} ]), app.controller("channelsController", [ "$rootScope", "$scope", "$window", "$state", "$uibModal", "$q", "channelsService", "webNotification", "textUtil", "$log", "CurrentMember", function($rootScope, $scope, $window, $state, $uibModal, $q, channelsService, webNotification, textUtil, $log, CurrentMember) {
    function sendBrowserNotification(channel) {
        webNotification.showNotification(channel.name, {
            body: "شما " + channel.getLocaleNotifCount() + " پیام خوانده نشده دارید.",
            icon: "favicon.png",
            onClick: function() {
                channel.hideNotifFunction(), channel.hideNotifFunction = null, $window.focus(),
                $state.go("messenger.messages", {
                    slug: channel.getUrlifiedSlug()
                });
            }
        }, function(error, hide) {
            error ? $log.error("Unable to show notification: " + error.message) : (channel.hideNotifFunction = hide,
            setTimeout(function() {
                channel.hideNotifFunction = null, hide();
            }, 5e3));
        });
    }
    function validateUrlChannel() {
        $scope.channels.current || $state.go("messenger.home");
    }
    function updateChannels() {
        $scope.channels.publicsAndPrivates = channelsService.getPublicsAndPrivates(), $scope.channels.directs = channelsService.getDirects();
    }
    function updateFavicon() {
        $rootScope.hasUnread = channelsService.anyChannelHasUnread();
    }
    function incrementChannelNotification(channelId) {
        channelsService.updateChannelNotification(channelId, "inc");
    }
    $scope.channels = {}, $scope.channels.publicsAndPrivates = [], $scope.channels.directs = [],
    $scope.$on("channels:updated", function() {
        updateChannels(), updateFavicon();
    }), $scope.$on("channel:changed", function() {
        $scope.channels.current = channelsService.getCurrentChannel(), validateUrlChannel();
    }), $scope.$on("message", function(event, message) {
        var channel = channelsService.findChannelById(message.channelId);
        if ($rootScope.isTabFocused) if ($scope.channels.current) {
            var belongsToCurrentChannel = message.channelId === $scope.channels.current.id;
            belongsToCurrentChannel || message.isFromMe() || incrementChannelNotification(message.channelId);
        } else incrementChannelNotification(message.channelId); else incrementChannelNotification(message.channelId),
        channel.shouldSendNotification() && sendBrowserNotification(channel);
    }), $scope.openTeamProfileModal = function(tour) {
        var tourClicked = !1;
        tour.getStatus() === tour.Status.ON && (tourClicked = !0, tour.end());
        $uibModal.open({
            animation: !0,
            templateUrl: "app/components/profile/team.profile.view.html?v=1.0.0",
            controller: "teamProfileController",
            resolve: {
                tourClicked: function() {
                    return tourClicked;
                }
            }
        });
    }, $scope.openCreateChannelModal = function(name) {
        $uibModal.open({
            animation: !0,
            templateUrl: "app/components/messenger/channels/channel-create.view.html?v=1.0.1",
            controller: "createChannelController"
        }).result.then(function() {}, function() {});
    }, $scope.navigateToAndWaitFor = function(tour, stepId) {
        if ($scope.channels.publicsAndPrivates.length) return $state.go("messenger.messages", {
            slug: $scope.channels.publicsAndPrivates[0].slug
        }), tour.waitFor(stepId);
    }, $scope.scrollToDirects = function() {
        document.getElementById("groups").scrollTop = document.getElementById("channels").scrollHeight;
    }, $scope.navigateToHomeAndScrollToChannels = function() {
        $state.go("messenger.home"), document.getElementById("groups").scrollTop = 0;
    }, $scope.scrollToProgress = function() {
        var groups = document.getElementById("groups");
        groups.scrollTop = groups.scrollHeight;
    };
} ]), app.service("channelsService", [ "$rootScope", "$http", "$q", "$log", "socket", "Channel", "$state", "CurrentMember", "Team", "ArrayUtil", function($rootScope, $http, $q, $log, socket, Channel, $state, CurrentMember, Team, ArrayUtil) {
    function getInitialChannels() {
        socket.emit("channel:init", null, function(results) {
            ArrayUtil.sortByKeyDesc(results, "lastMessageDatetime"), self.channels = [], self.initChannelsCount = results.length,
            0 === self.initChannelsCount && ($rootScope.isLoading = !1), Team.membersPromise.then(function() {
                results.forEach(function(result) {
                    var channel = createAndPushChannel(result);
                    $rootScope.$emit("channel:new", channel);
                });
            }), self.initialChannelsGottenForFirstTime = !0;
        });
    }
    function setChannelLivedFileId(channelId, fileId) {
        findChannelById(channelId).liveFileId = fileId, $rootScope.$broadcast("channels:updated");
    }
    function setDirectActiveState(username, state) {
        findChannelBySlug(username).active = state;
    }
    function createAndPushChannel(data) {
        var channel = new Channel(data.name, data.slug, data.description, data.type, data.id, data.membersCount, data.memberId, data.isFakeDirect, data.liveFileId, data.teamId, data.isCurrentMemberChannelMember, data.isMuted, data.lastSeenMessageId, data.lastMessageDatetime, data.lastMessageId, data.memberLastSeenMessageId);
        if (channel.isDirect() && !channel.isFakeDirect && !CurrentMember.member.isTecomBot()) {
            channel.changeNameAndSlugFromId(), Team.isMemberActiveByUsername(channel.slug) || (channel.active = !1);
            var fakeDirect = findChannelBySlug(channel.slug);
            if (fakeDirect) return fakeDirect.setValues(channel.name, channel.slug, channel.description, channel.type, channel.id, channel.membersCount, null, channel.memberId, !1, channel.liveFileId),
            fakeDirect;
        }
        return self.channels.push(channel), channel;
    }
    function findChannelById(id) {
        return ArrayUtil.getElementByKeyValue(self.channels, "id", id);
    }
    function findChannelBySlug(slug) {
        return ArrayUtil.getElementByKeyValue(self.channels, "slug", slug);
    }
    function setCurrentChannelBySlug(slug) {
        var defer = $q.defer();
        if (slug) {
            var channel = findChannelBySlug(slug);
            channel ? channel.isDirect() && channel.isFakeDirect ? createDirect(channel.member.id).then(function() {
                setCurrentChannel(channel), defer.resolve();
            }) : (setCurrentChannel(channel), defer.resolve()) : (setCurrentChannel(null), defer.resolve());
        } else setCurrentChannel(null), defer.resolve();
        return defer.promise;
    }
    function setCurrentChannel(channel) {
        self.currentChannel = channel, $rootScope.$broadcast("channel:changed");
    }
    function getCurrentChannel() {
        return self.currentChannel;
    }
    function areChannelsReady() {
        return !$rootScope.isLoading;
    }
    function toggleIsMuted(channelId) {
        var deferred = $q.defer(), data = {
            channelId: channelId
        };
        return socket.emit("channel:mute:toggle", data, function(res) {
            res.status ? deferred.resolve() : (deferred.reject(res.message), $log.error("Toggle Channel Disturb Mode failed.", res.message));
        }), deferred.promise;
    }
    function createChannel(channel) {
        var deferred = $q.defer();
        return socket.emit("channel:create", channel, function(res) {
            res.status ? deferred.resolve() : (deferred.reject(res.message), $log.error("Create channel failed.", res.message));
        }), deferred.promise;
    }
    function sendEditedChannel(channel) {
        var defer = $q.defer();
        return socket.emit("channel:edit:details", channel, function(res) {
            res.status ? defer.resolve() : defer.reject(res.message);
        }), defer.promise;
    }
    function addMembersToChannel(memberIds, channelId) {
        var defer = $q.defer(), data = {
            memberIds: memberIds,
            channelId: channelId
        };
        return socket.emit("channel:members:add", data, function(res) {
            res.status ? defer.resolve(res.channelMembers) : defer.reject();
        }), defer.promise;
    }
    function removeMemberFromChannel(data) {
        var defer = $q.defer();
        return socket.emit("channel:members:remove", data, function(res) {
            res.status ? defer.resolve() : defer.reject(res.message);
        }), defer.promise;
    }
    function createDirect(memberId) {
        var deferred = $q.defer(), data = {
            memberId: memberId
        };
        return socket.emit("channel:direct:create", data, function(res) {
            res.status ? deferred.resolve() : (deferred.reject(), $log.error("Creating direct channel failed.", res.message));
        }), deferred.promise;
    }
    function updateChannelNotification(channelId, type) {
        var channel = findChannelById(channelId);
        switch (type) {
          case "empty":
            channel.memberLastSeenId = channel.lastMessageId;
            break;

          case "inc":
            channel.lastMessageId ? channel.lastMessageId++ : channel.lastMessageId = 1;
        }
        $rootScope.$broadcast("channels:updated");
    }
    function updateChannelLastDatetime(channelId, datetime) {
        findChannelById(channelId).setLastDatetime(datetime), $rootScope.$broadcast("channels:updated");
    }
    function updateChannelLastSeen(channelId, lastSeenMessageId) {
        findChannelById(channelId).setLastSeen(lastSeenMessageId), $rootScope.$broadcast("channels:updated");
    }
    function addIsTypingMemberByChannelId(channelId, memberId) {
        findChannelById(channelId).addIsTypingMemberId(memberId), $rootScope.$broadcast("channels:updated");
    }
    function removeIsTypingMemberByChannelId(channelId, memberId) {
        findChannelById(channelId).removeIsTypingMemberId(memberId), $rootScope.$broadcast("channels:updated");
    }
    function addMessagesPromise(promise) {
        var maxInitialChannels = Math.min(self.initChannelsCount, MAX_INITIAL_CHANNELS);
        self.messagesPromise || (self.messagesPromise = []), self.messagesPromise.length < maxInitialChannels && (self.messagesPromise.push(promise),
        self.messagesPromise.length == maxInitialChannels && $q.all(self.messagesPromise).then(function() {
            $rootScope.$broadcast("channels:updated", "init");
        }));
    }
    function getChannelMembers(channelId) {
        var deferred = $q.defer();
        return $http({
            method: "GET",
            url: "/api/v1/messenger/channels/" + channelId + "/members/"
        }).then(function(data) {
            deferred.resolve(data);
        }).catch(function(err) {
            $log.info("Error Getting channel members.", err), deferred.reject(err);
        }), deferred.promise;
    }
    function anyChannelHasUnread() {
        for (var i = 0; i < self.channels.length; i++) if (self.channels[i].hasUnread() && self.channels[i].isCurrentMemberPublicChannelMember()) return !0;
        return !1;
    }
    function getChannels() {
        return self.channels;
    }
    function getPublicsAndPrivates() {
        return self.channels.filter(function(channel) {
            return channel.isPublic() || channel.isPrivate();
        });
    }
    function getDirects() {
        return self.channels.filter(function(channel) {
            return channel.isDirect();
        });
    }
    function removeChannel(channelId) {
        ArrayUtil.removeElementByKeyValue(self.channels, "id", channelId), $rootScope.$broadcast("channels:updated");
    }
    function archiveChannel(channelId) {
        var defer = $q.defer(), data = {
            channelId: channelId
        };
        return socket.emit("channel:archive", data, function(results) {
            results.status ? ($log.info("Channel succesfully Archived"), defer.resolve()) : ($log.error("Error Archiving Channel : ", results.message),
            defer.reject());
        }), defer.promise;
    }
    var self = this, MAX_INITIAL_CHANNELS = 5;
    return self.channels = [], self.initialChannelsGottenForFirstTime = !1, function() {
        getInitialChannels();
    }(), socket.on("channel:new", function(result) {
        var channel = createAndPushChannel(result.channel);
        result.channel.creatorId === CurrentMember.member.id && $state.go("messenger.messages", {
            slug: channel.getUrlifiedSlug()
        }), $rootScope.$broadcast("channels:updated");
    }), socket.on("channel:edit", function(result) {
        var channel = findChannelById(result.channel.id), isChannelSelected = channel.isSelected();
        channel.updateFromJson(result.channel), isChannelSelected && $state.go("messenger.messages", {
            slug: channel.slug
        }), $rootScope.$broadcast("channels:updated");
    }), socket.on("channel:members:add", function(result) {
        $log.info("add member:", result);
        var channel;
        if (result.channel.type === Channel.TYPE.PUBLIC) channel = findChannelById(result.channel.id),
        channel.isCurrentMemberChannelMember = !0; else if (result.channel.type === Channel.TYPE.PRIVATE) {
            createAndPushChannel(result.channel), $rootScope.$broadcast("channels:updated"),
            channel = findChannelById(result.channel.id);
            var data = {
                channelId: result.channel.id
            };
            socket.emit("channel:messagedata", data, function(res) {
                channel.lastMessageId = res.lastMessageId, channel.memberLastSeenId = res.lastMessageId - 1,
                $rootScope.$emit("channel:new", channel);
            });
        }
    }), socket.on("channel:members:remove", function(result) {
        var channel = findChannelById(result.channel.id);
        result.channel.type === Channel.TYPE.PUBLIC ? channel.isCurrentMemberChannelMember = !1 : result.channel.type === Channel.TYPE.PRIVATE && (channel.setIsRemoved(),
        $rootScope.$broadcast("channels:updated"));
    }), socket.on("channel:archived", function(result) {
        var channel = findChannelById(result.channelId);
        channel && (channel.setIsArchived(), $rootScope.$broadcast("channels:updated"));
    }), socket.on("channel:mute:toggle", function(channelId) {
        var channel = findChannelById(channelId);
        channel && (channel.isMuted = !channel.isMuted);
    }), $rootScope.$on("socket:connected", function() {
        self.initialChannelsGottenForFirstTime && getInitialChannels();
    }), {
        getPublicsAndPrivates: getPublicsAndPrivates,
        getDirects: getDirects,
        getChannels: getChannels,
        anyChannelHasUnread: anyChannelHasUnread,
        createAndPushChannel: createAndPushChannel,
        findChannelById: findChannelById,
        findChannelBySlug: findChannelBySlug,
        setCurrentChannelBySlug: setCurrentChannelBySlug,
        getCurrentChannel: getCurrentChannel,
        areChannelsReady: areChannelsReady,
        toggleIsMuted: toggleIsMuted,
        createChannel: createChannel,
        sendEditedChannel: sendEditedChannel,
        addMembersToChannel: addMembersToChannel,
        removeMemberFromChannel: removeMemberFromChannel,
        updateChannelNotification: updateChannelNotification,
        updateChannelLastDatetime: updateChannelLastDatetime,
        updateChannelLastSeen: updateChannelLastSeen,
        addIsTypingMemberByChannelId: addIsTypingMemberByChannelId,
        removeIsTypingMemberByChannelId: removeIsTypingMemberByChannelId,
        addMessagesPromise: addMessagesPromise,
        getChannelMembers: getChannelMembers,
        setChannelLivedFileId: setChannelLivedFileId,
        setDirectActiveState: setDirectActiveState,
        archiveChannel: archiveChannel,
        removeChannel: removeChannel
    };
} ]), app.controller("headerController", [ "$scope", "$localStorage", "$uibModal", "$window", "AuthService", "db", "channelsService", "$state", function($scope, $localStorage, $uibModal, $window, AuthService, db, channelsService, $state) {
    $scope.$on("channel:changed", function() {
        $scope.channel = channelsService.getCurrentChannel();
    }), $scope.toggleIsMuted = function() {
        channelsService.toggleIsMuted($scope.channel.id);
    }, $scope.openChannelDetailsModal = function() {
        if ($scope.channel) {
            $uibModal.open({
                templateUrl: "app/components/messenger/channels/channel-details.view.html?v=1.0.1",
                controller: "channelDetailsController"
            });
        }
    }, $scope.clearCache = function() {
        $localStorage.$reset(), db.destroy(), AuthService.logout().then(function() {
            $window.location.href = "/login";
        });
    };
} ]), app.factory("Message", [ "$log", "db", "textUtil", "channelsService", "fileUtil", "dateUtil", "CurrentMember", "Team", function($log, db, textUtil, channelsService, fileUtil, dateUtil, CurrentMember, Team) {
    function Message(body, type, senderId, channelId, _id, datetime, additionalData, about, isPending, fileTimestamp) {
        this.setValues(body, type, senderId, channelId, _id, datetime, additionalData, about, isPending, fileTimestamp);
    }
    return Message.prototype.setValues = function(body, type, senderId, channelId, _id, datetime, additionalData, about, isPending, fileTimestamp) {
        this.body = body, this.type = type, this.senderId = senderId, this.channelId = channelId,
        this._id = _id || null, this.about = about || null, this.datetime = datetime ? new Date(datetime) : new Date(),
        this.additionalData = additionalData || null, this._id && (this.id = Message.generateIntegerId(_id)),
        this.isPending = isPending || !1, this.currentChannel = channelsService.getCurrentChannel(),
        this.currentChannel && (this.teamId = this.currentChannel.teamId), this.fileTimestamp = fileTimestamp,
        this.uploadProgressBar = null;
    }, Message.prototype.getUsername = function() {
        if (CurrentMember.member.isTecomBot() || this.isLoading()) return "";
        var username = Team.getUsernameByMemberId(this.senderId);
        return this.isNotif() || "" !== username || $log.error("Empty username problem. Team members:"),
        username;
    }, Message.prototype.getUsernameColor = function() {
        return CurrentMember.member.isTecomBot() || !this.senderId || this.senderId === CurrentMember.member.id ? {} : Team.getMemberByMemberId(this.senderId) ? {
            color: Team.getMemberByMemberId(this.senderId).user.usernameColor
        } : {};
    }, Message.prototype.getViewWellFormed = function() {
        var body = "";
        if (this.type === Message.TYPE.TEXT) this.about && (body += '<a class="msg-attachment" ng-click="showFileLine(' + this.about.fileId + "," + this.about.lineNumber + "," + this.about.lineNumberTo + ')" tooltip-placement="top" uib-tooltip="در مورد...">',
        body += '<div><i class="zmdi zmdi-link"></i></div></a>'), body += Message.generateMessageWellFormedText(this.body); else {
            if (this.isFile()) return this.canBeLived = fileUtil.isTextFormat(this.additionalData.type),
            body = '<div id="' + this.getFileTimestampId() + '" class="ng-scope" dir="rtl">',
            fileUtil.isPictureFormat(this.additionalData.type) ? body += '<img class="img-responsive" id="img-' + this.additionalData.fileId + '" ng-src="' + this.additionalData.url + '" style="cursor:pointer" fullscreen />' : (body += '<label class="file-name">' + this.additionalData.name + "</label>",
            body += '<div class="file-icon-holder"><i class="fa fa-file"></i></div><br>'), this.canBeLived && (this.currentChannel.canMemberSendMessage() && (body += '<a class="live-btn" dir="ltr" ng-click="goLive(' + this.additionalData.fileId + ", '" + this.additionalData.name + "')\">",
            body += '<label dir="ltr">LIVE</label>', body += '<i class="fa fa-circle"></i>',
            body += "</a>"), body += '<a class="dl-btn" ng-click="viewFile(' + this.additionalData.fileId + ')" tooltip-placement="top" uib-tooltip="مشاهده">',
            body += '<i class="fa fa-eye"></i>'), body += '<a class="dl-btn" href="' + this.additionalData.url + '" download="' + this.additionalData.name + '" target="_blank" tooltip-placement="top" uib-tooltip="دانلود">',
            body += '<i class="zmdi zmdi-download"></i>', body += "</a></div>";
            if (this.type === Message.TYPE.NOTIF.USER_ADDED || this.type === Message.TYPE.NOTIF.USER_REMOVED) {
                body = "";
                var addedMemberIds = this.additionalData;
                angular.forEach(addedMemberIds, function(memberId) {
                    body += "@" + Team.getUsernameByMemberId(memberId) + " و ";
                }), body = body.slice(0, body.length - 3), this.type === Message.TYPE.NOTIF.USER_ADDED ? body += addedMemberIds.length > 1 ? " به گروه اضافه شدند." : " به گروه اضافه شد." : body += addedMemberIds.length > 1 ? " از گروه حذف شدند." : " از گروه حذف شد.";
            } else this.type === Message.TYPE.NOTIF.CHANNEL_CREATED ? body = "گروه ساخته شد." : this.type === Message.TYPE.NOTIF.CHANNEL_EDITED ? body = "اطلاعات گروه تغییر کرد." : this.type === Message.TYPE.NOTIF.FILE_LIVED ? body = 'فایل "' + this.additionalData.fileName + '"، <span class="live-btn"><label dir="ltr">LIVE</label><i class="fa fa-circle"></i></span> شد.' : this.type === Message.TYPE.NOTIF.FILE_DIED ? body = 'فایل "' + this.additionalData.fileName + '"، از حالت <span class="live-btn"><label dir="ltr">LIVE</label><i class="fa fa-circle"></i></span> خارج شد.' : this.type === Message.TYPE.LOADING && (body = '<div class="cssload-container"><div class="loading-text">در حال بارگذاری...</div></div>');
        }
        return body;
    }, Message.prototype.isFromMe = function() {
        return this.senderId === CurrentMember.member.id;
    }, Message.prototype.isEnglish = function() {
        return !!this.body && textUtil.isEnglish(this.body);
    }, Message.prototype.isLoading = function() {
        return this.type === Message.TYPE.LOADING;
    }, Message.prototype.getStyle = function() {
        return this.isFile() || this.isEnglish() ? {
            "text-align": "left",
            direction: "ltr"
        } : {};
    }, Message.prototype.getStatus = function() {
        return this.channel || (this.channel = channelsService.findChannelById(this.channelId),
        this.channel) ? this.isPending ? Message.STATUS_TYPE.PENDING : this.id <= this.channel.lastSeenId ? Message.STATUS_TYPE.SEEN : Message.STATUS_TYPE.SENT : Message.STATUS_TYPE.SEEN;
    }, Message.prototype.getFileTimestampId = function() {
        return "file-" + this.fileTimestamp;
    }, Message.prototype.getStatusIcon = function() {
        switch (this.getStatus()) {
          case Message.STATUS_TYPE.PENDING:
            return "zmdi zmdi-time";

          case Message.STATUS_TYPE.SENT:
            return "zmdi zmdi-check";

          case Message.STATUS_TYPE.SEEN:
            return "zmdi zmdi-check-all";
        }
    }, Message.prototype.getCssClass = function() {
        switch (this.type) {
          case Message.TYPE.TEXT:
          case Message.TYPE.FILE:
            return this.isFromMe() ? "msg msg-send" : "msg msg-recieve";

          case Message.TYPE.NOTIF.USER_ADDED:
          case Message.TYPE.NOTIF.USER_REMOVED:
          case Message.TYPE.NOTIF.FILE_LIVED:
          case Message.TYPE.NOTIF.FILE_DIED:
          case Message.TYPE.NOTIF.CHANNEL_CREATED:
          case Message.TYPE.NOTIF.CHANNEL_EDITED:
            return "notif";

          case Message.TYPE.LOADING:
            return "msg-loading";
        }
    }, Message.prototype.setIdAndDatetime = function(_id, datetime) {
        this._id = _id, this.id = Message.generateIntegerId(_id), this.datetime = new Date(datetime);
    }, Message.prototype.setId = function(id) {
        this.id = id;
    }, Message.generateIntegerId = function(stringId) {
        return parseInt(stringId.slice(stringId.lastIndexOf(":") + 1, stringId.length));
    }, Message.prototype.getServerWellFormed = function() {
        var data = {
            channelId: this.channelId,
            teamId: this.teamId,
            messageBody: this.body,
            type: this.type
        };
        return this.additionalData && (data.additionalData = this.additionalData), this.about && (data.about = this.about),
        data;
    }, Message.prototype.getDbWellFormed = function() {
        var data = {
            _id: this._id,
            id: this.id,
            body: this.body,
            senderId: this.senderId,
            channelId: this.channelId,
            datetime: this.datetime,
            type: this.type
        };
        return this.additionalData && (data.additionalData = this.additionalData), this.about && (data.about = this.about),
        data;
    }, Message.prototype.save = function() {
        var that = this;
        db.getDb().then(function(database) {
            database.put(that.getDbWellFormed()).catch(function(err) {
                $log.error("Saving message failed.", err);
            });
        });
    }, Message.generateMessageWellFormedText = function(text) {
        var wellFormedText = textUtil.htmlToPlaintext(text);
        return wellFormedText = textUtil.htmlify(wellFormedText);
    }, Message.prototype.isNotif = function() {
        return this.type === Message.TYPE.NOTIF.USER_ADDED || this.type === Message.TYPE.NOTIF.USER_REMOVED || this.type === Message.TYPE.NOTIF.FILE_LIVED || this.type === Message.TYPE.NOTIF.CHANNEL_CREATED || this.type === Message.TYPE.NOTIF.CHANNEL_EDITED || this.type === Message.TYPE.NOTIF.FILE_DIED;
    }, Message.prototype.isFile = function() {
        return this.type === Message.TYPE.FILE;
    }, Message.prototype.getLocaleDate = function() {
        return dateUtil.getPersianDateString(this.datetime);
    }, Message.prototype.getLocaleTime = function() {
        return dateUtil.getPersianTime(this.datetime);
    }, Message.TYPE = {
        TEXT: 0,
        FILE: 1,
        NOTIF: {
            USER_ADDED: 2,
            USER_REMOVED: 3,
            FILE_LIVED: 4,
            CHANNEL_CREATED: 5,
            CHANNEL_EDITED: 6,
            FILE_DIED: 7
        },
        LOADING: 8
    }, Message.STATUS_TYPE = {
        PENDING: 0,
        SENT: 1,
        SEEN: 2
    }, Message;
} ]), app.controller("messagesController", [ "$scope", "$rootScope", "$state", "$stateParams", "$window", "$timeout", "Message", "messagesService", "channelsService", "filesService", "$q", "ArrayUtil", "textUtil", "CurrentMember", "ngProgressFactory", function($scope, $rootScope, $state, $stateParams, $window, $timeout, Message, messagesService, channelsService, filesService, $q, ArrayUtil, textUtil, CurrentMember, ngProgressFactory) {
    function scrollBottom() {
        $timeout(function() {
            messagesHolder.scrollTop = messagesHolder.scrollHeight;
        }, 0, !1);
    }
    function checkShouldScrollBottom() {
        messagesHolder.scrollHeight - messagesHolder.scrollTop < 1.5 * messagesWindow.scrollHeight && scrollBottom();
    }
    function scrollToUnseenMessage() {
        scrollToMessageElementById($scope.channel.areAllMessagesHaveBeenSeen() ? $scope.channel.memberLastSeenId : $scope.channel.memberLastSeenId + 1);
    }
    function finishLoading() {
        $rootScope.isLoading = !1, $rootScope.$broadcast("loading:finished");
    }
    function initialize() {
        var deferred = $q.defer();
        return initialLastMessageId = $scope.channel.lastMessageId, $scope.channel.areAllMessagesHaveBeenSeen() || (initialMemberLastSeenId = $scope.channel.memberLastSeenId),
        $rootScope.$broadcast("channel:ready", $scope.channel), bindMessages().then(deferred.resolve()),
        $scope.inputMessage = "", deferred.promise;
    }
    function generateUploadProgressBar(message) {
        $timeout(function() {
            var parentId = message.getFileTimestampId();
            message.uploadProgressBar = ngProgressFactory.createInstance(), message.uploadProgressBar.setColor("#24A772"),
            message.uploadProgressBar.setParent(document.getElementById(parentId)), message.uploadProgressBar.setAbsolute(),
            message.uploadProgressBar.start(), message.uploadProgressBar.set(2);
        }, 0, !1);
    }
    function getLoadingMessages(channelId, from, to, isDirectionUp) {
        messagesService.getMessagesRangeFromServer(channelId, CurrentMember.member.teamId, from, to).then(function(messages) {
            removeLoadingMessage(from), messages.forEach(function(message) {
                ArrayUtil.containsKeyValue($scope.messages, "id", message.id) || $scope.messages.push(message);
            }), isAnyLoadingMessageGetting = !1, getMessagePackagesIfLoadingsInView(isDirectionUp);
        });
    }
    function setCurrentChannel() {
        var deferred = $q.defer(), slug = $stateParams.slug ? $stateParams.slug.replace("@", "") : null;
        return channelsService.setCurrentChannelBySlug(slug).then(function() {
            $scope.channel = channelsService.getCurrentChannel(), deferred.resolve();
        }), deferred.promise;
    }
    function bindMessages() {
        var deferred = $q.defer();
        return messagesService.getMessagesByChannelId($scope.channel.id, $scope.channel.lastMessageId).then(function(messages) {
            if ($scope.messages = messages, scrollToUnseenMessage(), $scope.channel.hasUnread()) {
                var lastMessage = ArrayUtil.getElementByKeyValue($scope.messages, "id", $scope.channel.lastMessageId);
                messagesService.seenMessage($scope.channel.id, lastMessage.id, lastMessage.senderId),
                $timeout(function() {
                    isBottomOfMessagesHolder() || (hasUnreadInitializeMessages = !0), $scope.$apply();
                });
            }
            deferred.resolve();
        }), deferred.promise;
    }
    function seenLastUnSeenMessage() {
        self.lastUnSeenMessage && (messagesService.seenMessage($scope.channel.id, self.lastUnSeenMessage.id, self.lastUnSeenMessage.senderId),
        self.lastUnSeenMessage = null);
    }
    function clearMessageInput() {
        $scope.inputMessage = "";
    }
    function removeLoadingMessage(messageId) {
        ArrayUtil.removeElementByKeyValue($scope.messages, "id", messageId);
    }
    function scrollToMessageElementById(elementId) {
        $timeout(function() {
            var messageElement = getMessageElementById(elementId);
            messageElement && (messagesHolder.scrollTop = messageElement.offsetTop - messagesWindow.offsetTop);
        }, 0, !1);
    }
    function isElementInViewPort(element, isDirectionUp) {
        return isDirectionUp ? element.offsetTop > messagesHolder.scrollTop && element.offsetTop < messagesHolder.scrollTop + messagesHolder.scrollHeight : element.offsetTop > messagesHolder.scrollTop + messagesWindow.scrollHeight && element.offsetTop < messagesHolder.scrollTop + 2 * messagesWindow.scrollHeight;
    }
    function filterLoadingMessages() {
        return $scope.messages.filter(function(message) {
            return message.isLoading();
        });
    }
    function getMessageElementById(id) {
        return document.getElementById("message_" + id);
    }
    function getMessagePackagesIfLoadingsInView(isDirectionUp) {
        filterLoadingMessages().forEach(function(message) {
            isElementInViewPort(getMessageElementById(message.id), isDirectionUp) && !isAnyLoadingMessageGetting && (getLoadingMessages(message.additionalData.channelId, message.additionalData.from, message.additionalData.to, isDirectionUp),
            isAnyLoadingMessageGetting = !0);
        });
    }
    function updateUnreadFlagsToCheckIfSeenMessages() {
        $scope.hasUnreadNewMessages = $scope.hasUnreadNewMessages && !isBottomOfMessagesHolder(),
        hasUnreadInitializeMessages = hasUnreadInitializeMessages && !isBottomOfMessagesHolder();
    }
    function isBottomOfMessagesHolder() {
        return messagesHolder.scrollTop + messagesWindow.scrollHeight > messagesHolder.scrollHeight;
    }
    var self = this;
    $scope.messages = [], $scope.hasUnreadNewMessages = !1;
    var isAnyLoadingMessageGetting, prevScrollTop, initialMemberLastSeenId, initialLastMessageId, messagesHolder = document.getElementById("messagesHolder"), messagesWindow = document.getElementById("messagesWindow"), isJumpDownScrollingDown = !1, hasUnreadInitializeMessages = !1;
    if ($scope.$on("channels:updated", function(event, data) {
        "init" === data && setCurrentChannel().then(function() {
            $scope.channel ? $scope.channel.initialMessagesPromise.then(function() {
                return initialize();
            }).then(function() {
                finishLoading();
            }) : finishLoading();
        });
    }), !$stateParams.slug) return void channelsService.setCurrentChannelBySlug(null);
    channelsService.areChannelsReady() && setCurrentChannel().then(function() {
        $scope.channel.initialMessagesPromise.then(initialize());
    }), $scope.$on("type:start", function(event, channelId) {
        $scope.channel.id === channelId && checkShouldScrollBottom();
    }), $scope.$on("message", function(event, message) {
        $scope.channel.id == message.channelId && (isBottomOfMessagesHolder() || ($scope.hasUnreadNewMessages = !0,
        $timeout(function() {
            $scope.$apply();
        })), $rootScope.isTabFocused ? ($scope.channel.seenLastMessage(), messagesService.seenMessage($scope.channel.id, message.id, message.senderId)) : self.lastUnSeenMessage = message,
        $scope.messages.push(message), message.isFile() && filesService.createFileManagerFile(message.additionalData.fileId, message.additionalData.url, message.additionalData.name, message.datetime, message.additionalData.type),
        checkShouldScrollBottom());
    }), $scope.$on("file:uploading", function(event, file) {
        $scope.uploadErrNotif = !1;
        var message = messagesService.sendFileAndGetMessage($scope.channel.id, file, file.name);
        $scope.messages.push(message), scrollBottom(), generateUploadProgressBar(message);
    }), $scope.$on("file:uploadError", function() {
        self.uploadErrNotifTimeout && $timeout.cancel(self.uploadErrNotifTimeout), $scope.uploadErrNotif || ($scope.uploadErrNotif = !0),
        self.uploadErrNotifTimeout = $timeout(function() {
            $scope.uploadErrNotif = !1;
        }, 3e3);
    }), $scope.upload = function(file, errFiles) {
        $rootScope.$broadcast("file:upload", file, errFiles);
    }, $scope.getInputStyle = function() {
        return textUtil.isEnglish($scope.inputMessage) ? {
            "text-align": "left",
            direction: "ltr"
        } : {};
    }, $scope.sendMessage = function($event) {
        $event.preventDefault();
        var messageBody = $scope.inputMessage.trim();
        if (messageBody) {
            $scope.channel.seenLastMessage();
            var message = messagesService.sendAndGetMessage($scope.channel.id, messageBody);
            $scope.messages.push(message), scrollBottom(), clearMessageInput(), messagesService.endTyping($scope.channel.id),
            $timeout.cancel(self.isTypingTimeout), self.isTyping = !1;
        }
    }, $scope.typing = function() {
        self.isTypingTimeout && $timeout.cancel(self.isTypingTimeout), self.isTyping || (self.isTyping = !0,
        messagesService.startTyping($scope.channel.id)), self.isTypingTimeout = $timeout(function() {
            self.isTyping = !1, messagesService.endTyping($scope.channel.id);
        }, 2e3);
    }, $scope.showFileLine = function(fileId, startLine, endLine) {
        filesService.showFileLine(fileId, startLine, endLine);
    }, $scope.navigateToAndWaitFor = function() {
        $state.go("messenger.home");
    }, $scope.shouldShowJumpDownButton = function() {
        return isJumpDownScrollingDown || $scope.hasUnreadNewMessages || hasUnreadInitializeMessages;
    }, $scope.jumpDown = function() {
        isAnyLoadingMessageGetting = !0, scrollToMessageElementById($scope.channel.lastMessageId),
        isAnyLoadingMessageGetting = !1;
    }, $scope.isMessageDateInAnotherDay = function(message) {
        if (1 === message.id) return !0;
        var previousMessage = ArrayUtil.getElementByKeyValue($scope.messages, "id", message.id - 1);
        if (previousMessage) {
            var timeDiff = Math.abs(message.datetime.getTime() - previousMessage.datetime.getTime());
            return 0 !== Math.floor(timeDiff / 864e5);
        }
    }, $scope.goLive = function(fileId, fileName) {
        filesService.makeFileLive($scope.channel.id, fileId, fileName);
    }, $scope.viewFile = function(fileId) {
        filesService.viewFile(fileId);
    }, $scope.archiveDirect = function(channel) {
        channelsService.archiveChannel(channel.id).then(function() {
            $scope.removeAndCloseChannel(channel);
        }).catch(function() {});
    }, $scope.removeAndCloseChannel = function(channel) {
        channelsService.removeChannel(channel.id), $state.go("messenger.home");
    }, $scope.joinPublicChannel = function() {
        channelsService.addMembersToChannel([ CurrentMember.member.id ], $scope.channel.id),
        $scope.channel.isCurrentMemberChannelMember = !0;
    }, $scope.isMessageFirstUnread = function(message) {
        return !!initialLastMessageId && message.id === initialMemberLastSeenId + 1;
    }, document.getElementById("inputPlaceHolder").focus(), angular.element(messagesHolder).bind("scroll", function() {
        var isDirectionUp, scrollTop = messagesHolder.scrollTop;
        prevScrollTop && (isDirectionUp = prevScrollTop > scrollTop), prevScrollTop = scrollTop,
        isJumpDownScrollingDown = !isBottomOfMessagesHolder() && !1 === isDirectionUp, getMessagePackagesIfLoadingsInView(isDirectionUp),
        updateUnreadFlagsToCheckIfSeenMessages(), $scope.$apply();
    }), document.onkeydown = function(evt) {
        evt = evt || $window.event, 27 == evt.keyCode && $state.go("messenger.home");
    }, $scope.$on("tab:focus:changed", function() {
        $rootScope.isTabFocused && seenLastUnSeenMessage();
    });
} ]), app.service("messagesService", [ "$rootScope", "$http", "$log", "$q", "socket", "channelsService", "Message", "db", "filesService", "CurrentMember", "Team", "ArrayUtil", "FileManagerFile", function($rootScope, $http, $log, $q, socket, channelsService, Message, db, filesService, CurrentMember, Team, ArrayUtil, FileManagerFile) {
    function getAndSaveInitialMessagesByChannelFromServer(channel) {
        var periods = ($q.defer(), generateFromAndTo(channel.memberLastSeenId, channel.lastMessageId)), promises = periods.map(function(period) {
            return getInitialMessagesByChannelId(channel.id, channel.teamId, period.from, period.to);
        });
        return $q.all(promises);
    }
    function generateFromAndTo(memberLastSeenId, lastMessageId) {
        if (!lastMessageId) return [];
        var from = Math.max(memberLastSeenId - MESSAGE_MAX_PACKET_LENGTH / 4 + 1, 1), to = Math.min(memberLastSeenId + 3 * MESSAGE_MAX_PACKET_LENGTH / 4, lastMessageId);
        return 1 === from && (to = Math.min(MESSAGE_MAX_PACKET_LENGTH, lastMessageId)),
        to === lastMessageId && (from = Math.max(lastMessageId - MESSAGE_MAX_PACKET_LENGTH + 1, 1)),
        generatePeriodsBasedOnLastMessages(lastMessageId, from, to);
    }
    function generatePeriodsBasedOnLastMessages(lastMessageId, from, to) {
        var periods = [];
        return to < lastMessageId - MESSAGE_MAX_PACKET_LENGTH ? (periods.push({
            from: from,
            to: to
        }), periods.push({
            from: lastMessageId - MESSAGE_MAX_PACKET_LENGTH + 1,
            to: lastMessageId
        })) : periods.push({
            from: from,
            to: lastMessageId
        }), periods;
    }
    function bulkSaveMessage(messages) {
        var deferred = $q.defer();
        return db.getDb().then(function(database) {
            database.bulkDocs(messages).then(function() {
                deferred.resolve();
            }).catch(function(err) {
                deferred.reject(), $log.error("Bulk saving messages failed.", err);
            });
        }), deferred.promise;
    }
    function getMessagesRangeFromServer(channelId, teamId, fromId, toId) {
        var deferred = $q.defer(), dataToBeSend = {
            channelId: channelId,
            teamId: teamId,
            from: fromId,
            to: toId
        };
        return socket.emit("message:get", dataToBeSend, function(res) {
            var messages = res.messages.map(function(msg) {
                return new Message(msg.body, msg.type, msg.senderId, msg.channelId, msg.id, msg.datetime, msg.additionalData, msg.about);
            });
            deferred.resolve(messages), bulkSaveMessage(messages.map(function(message) {
                return message.getDbWellFormed();
            }));
        }), deferred.promise;
    }
    function getMessagesByChannelId(channelId, lastMessageId) {
        var deferred = $q.defer();
        return getMessagesByChannelIdFromDb(channelId).then(function(res) {
            var messages = res.docs.map(function(message) {
                return new Message(message.body, message.type, message.senderId, message.channelId, message._id, message.datetime, message.additionalData, message.about);
            });
            generateLoadingMessages(messages, channelId, lastMessageId), deferred.resolve(messages);
        }), deferred.promise;
    }
    function generateLoadingMessages(messages, channelId, lastMessageId) {
        if (messages.length > 0) {
            var firstDbMessageId = messages[0].id, lastDbMessageId = messages[messages.length - 1].id;
            generateMainLoadingMessages(messages, channelId), generateUpperLoadingMessages(messages, channelId, firstDbMessageId),
            generateLowerLoadingMessages(messages, channelId, lastMessageId, lastDbMessageId);
        } else generateUpperLoadingMessages(messages, channelId, lastMessageId);
    }
    function generateMainLoadingMessages(messages, channelId) {
        for (var i = 0; i < messages.length; i++) i !== messages.length - 1 && messages[i + 1].id - messages[i].id > 1 && createAndPushLoadingMessage(messages, channelId, messages[i].id + 1, messages[i + 1].id - 1);
    }
    function generateUpperLoadingMessages(messages, channelId, firstDbMessageId) {
        for (var packetStartPoint = firstDbMessageId - 1, i = firstDbMessageId - 1; i > 0; i--) (packetStartPoint - i >= MESSAGE_MAX_PACKET_LENGTH - 1 || 1 === i) && (createAndPushLoadingMessage(messages, channelId, i, packetStartPoint),
        packetStartPoint = i - 1);
    }
    function generateLowerLoadingMessages(messages, channelId, lastMessageId, lastDbMessageId) {
        for (var packetStartPoint = lastDbMessageId + 1, i = lastDbMessageId + 1; i <= lastMessageId; i++) (i - packetStartPoint >= MESSAGE_MAX_PACKET_LENGTH - 1 || i === lastMessageId - 1) && (createAndPushLoadingMessage(messages, channelId, packetStartPoint, i),
        packetStartPoint = i + 1);
    }
    function createAndPushLoadingMessage(messages, channelId, fromId, toId) {
        var additionalData = {
            channelId: channelId,
            from: fromId,
            to: toId
        };
        if (toId - fromId < MESSAGE_MAX_PACKET_LENGTH) {
            var loadingMessage = new Message(null, Message.TYPE.LOADING, null, channelId, null, null, additionalData, null, null);
            loadingMessage.setId(fromId), messages.push(loadingMessage);
        } else createAndPushLoadingMessage(messages, channelId, fromId, fromId + MESSAGE_MAX_PACKET_LENGTH - 1),
        createAndPushLoadingMessage(messages, channelId, fromId + MESSAGE_MAX_PACKET_LENGTH, toId);
    }
    function getMessagesByChannelIdFromDb(channelId) {
        var deferred = $q.defer();
        return db.getDb().then(function(database) {
            database.find({
                selector: {
                    id: {
                        $gt: null
                    },
                    channelId: {
                        $eq: channelId
                    }
                },
                sort: [ {
                    id: "asc"
                } ]
            }).then(function(docs) {
                deferred.resolve(docs);
            });
        }), deferred.promise;
    }
    function getInitialMessagesByChannelId(channelId, teamId, from, to) {
        return getInitialMessagesIdByChannelIdFromDb(channelId, from, to).then(function(ids) {
            var gaps = findGaps(ids, from, to);
            if (gaps.length) {
                var promises = gaps.map(function(gap) {
                    return getMessagesRangeFromServer(channelId, teamId, gap.from, gap.to);
                });
                return $q.all(promises);
            }
        });
    }
    function getInitialMessagesIdByChannelIdFromDb(channelId, from, to) {
        var deferred = $q.defer();
        return db.getDb().then(function(database) {
            database.find({
                selector: {
                    id: {
                        $gt: from - 1,
                        $lt: to + 1
                    },
                    channelId: {
                        $eq: channelId
                    }
                },
                fields: [ "id" ],
                sort: [ {
                    id: "asc"
                } ]
            }).then(function(data) {
                deferred.resolve(data.docs);
            });
        }), deferred.promise;
    }
    function findGaps(ids, from, to) {
        for (var gaps = [], diff = 0, i = from; i <= to; i++) {
            if (!ids[i - from - diff]) {
                gaps.push({
                    from: i,
                    to: to
                });
                break;
            }
            if (i !== ids[i - from - diff].id) {
                gaps.push({
                    from: i,
                    to: ids[i - from - diff].id - 1
                });
                var tempdiff = ids[i - from - diff].id - i;
                i = ids[i - from - diff], diff += tempdiff;
            }
        }
        return gaps;
    }
    function sendAndGetMessage(channelId, messageBody, type, fileName, fileUrl) {
        var additionalData = null, about = null;
        fileName && (additionalData = {
            name: fileName,
            url: fileUrl
        });
        var livedFile = filesService.getLivedFile();
        if (livedFile) {
            var tempLines = livedFile.getTempLines();
            tempLines && (about = {
                fileId: livedFile.id,
                lineNumber: tempLines.start,
                lineNumberTo: tempLines.end
            }), livedFile.deselectTempLines();
        }
        var message = new Message(messageBody, type || Message.TYPE.TEXT, CurrentMember.member.id, channelId, null, null, additionalData, about, !0);
        return socket.emit("message:send", message.getServerWellFormed(), function(data) {
            message.isPending = !1, message.setIdAndDatetime(data.id, data.datetime, data.additionalData),
            message.save(), channelsService.updateChannelLastDatetime(message.channelId, message.datetime);
        }), message;
    }
    function sendFileAndGetMessage(channelId, fileData, fileName) {
        var additionalData = {
            name: fileName
        }, message = new Message(null, Message.TYPE.FILE, CurrentMember.member.id, channelId, null, null, additionalData, null, !0, +new Date());
        return filesService.uploadFile(fileName, channelId, CurrentMember.member.id, fileData, message).then(function(res) {
            message.additionalData.url = res.data.file, message.additionalData.fileId = res.data.id,
            message.additionalData.type = res.data.type, socket.emit("message:send", message.getServerWellFormed(), function(data) {
                message.isPending = !1, message.setIdAndDatetime(data.id, data.datetime, data.additionalData),
                message.save(), channelsService.updateChannelLastDatetime(message.channelId, message.datetime);
            }), filesService.createFileManagerFile(res.data.id, res.data.file, res.data.name, res.data.date_uploaded, res.data.type);
        }).catch(function(err) {
            $log.error("Error Uploading File.", err);
        }), message;
    }
    function seenMessage(channelId, messageId, senderId) {
        var data = {
            channelId: channelId,
            teamId: channelsService.getCurrentChannel().teamId,
            messageId: messageId,
            senderId: senderId
        };
        socket.emit("message:seen", data), channelsService.updateChannelNotification(channelId, "empty");
    }
    function startTyping(channelId) {
        var data = {
            channelId: channelId
        };
        socket.emit("message:type:start", data);
    }
    function endTyping(channelId) {
        var data = {
            channelId: channelId
        };
        socket.emit("message:type:end", data);
    }
    var MESSAGE_MAX_PACKET_LENGTH = 20;
    return socket.on("message:send", function(data) {
        var message = new Message(data.body, data.type, data.senderId, data.channelId, data.id, data.datetime, data.additionalData, data.about);
        if (message.save(), message.type === Message.TYPE.NOTIF) {
            var channel = channelsService.findChannelById(message.channelId);
            message.type === Message.TYPE.NOTIF.USER_ADDED ? channel.membersCount = channel.membersCount + message.additionalData.length : message.type === Message.TYPE.NOTIF.USER_REMOVED && channel.membersCount--;
        }
        $rootScope.$broadcast("message", message), channelsService.updateChannelLastDatetime(message.channelId, message.datetime),
        message.about && filesService.showFileLine(message.about.fileId, message.about.lineNumber, message.about.lineNumberTo);
    }), socket.on("message:type:start", function(data) {
        channelsService.addIsTypingMemberByChannelId(data.channelId, data.memberId), $rootScope.$broadcast("channels:updated"),
        $rootScope.$broadcast("type:start", data.channelId);
    }), socket.on("message:type:end", function(data) {
        channelsService.removeIsTypingMemberByChannelId(data.channelId, data.memberId),
        $rootScope.$broadcast("channels:updated");
    }), socket.on("message:seen", function(data) {
        channelsService.updateChannelLastSeen(data.channelId, data.messageId);
    }), $rootScope.$on("channel:new", function(event, channel) {
        var promise;
        if (channel.isDirect() && channel.isFakeDirect) {
            var deferred = $q.defer();
            deferred.resolve(), promise = deferred.promise;
        } else promise = getAndSaveInitialMessagesByChannelFromServer(channel);
        channel.setInitialMessagesPromise(promise), channelsService.addMessagesPromise(promise);
    }), {
        getMessagesByChannelId: getMessagesByChannelId,
        sendAndGetMessage: sendAndGetMessage,
        sendFileAndGetMessage: sendFileAndGetMessage,
        getMessagesRangeFromServer: getMessagesRangeFromServer,
        seenMessage: seenMessage,
        startTyping: startTyping,
        endTyping: endTyping
    };
} ]), app.controller("MessengerCtrl", [ "$rootScope", "$scope", "$window", "$uibModal", "AuthService", "CurrentMember", "$localStorage", "$state", "$http", "$templateCache", function($rootScope, $scope, $window, $uibModal, AuthService, CurrentMember, $localStorage, $state, $http, $templateCache) {
    function cacheMessagesTemplates() {
        $http.get("app/components/messenger/messages/messages.view.html?v=1.0.8", {
            cache: $templateCache
        }), $http.get("app/components/messenger/header/header.view.html?v=1.0.4", {
            cache: $templateCache
        }), $http.get("app/components/files/files.view.html?v=1.0.6", {
            cache: $templateCache
        }), $http.get("app/components/files/filemanager-files.view.html?v=1.0.0", {
            cache: $templateCache
        });
    }
    function checkIfUserSeenTour() {
        $localStorage.userSeenTour || ($scope.tour.start(), $localStorage.userSeenTour = !0);
    }
    $scope.isAdmin = CurrentMember.member.isAdmin, $rootScope.isTabFocused = !0, $scope.activeFile = !1,
    $scope.openUserProfileModal = function() {
        $uibModal.open({
            animation: !0,
            templateUrl: "app/components/profile/user.profile.view.html",
            controller: "userProfileController"
        });
    }, $scope.openTeamProfileModal = function() {
        $uibModal.open({
            animation: !0,
            templateUrl: "app/components/profile/team.profile.view.html?v=1.0.0",
            controller: "teamProfileController",
            resolve: {
                tourClicked: function() {
                    return null;
                }
            }
        });
    }, function() {
        $window.Notification.requestPermission(), CurrentMember.initializeDontDisturbMode(),
        cacheMessagesTemplates();
    }(), $scope.$on("view:state:changed", function(event, state) {
        $scope.activeFile = "noFile" !== state;
    }), $scope.$on("loading:finished", function() {
        checkIfUserSeenTour();
    }), $scope.getPannelsCSS = function(pannel) {
        return "messages" === pannel ? $scope.activeFile ? "col-sm-6 col-lg- no-padding" : "col-sm-8 col-lg- no-padding" : "files" === pannel ? $scope.activeFile ? "col-sm-6 col-lg-6 no-padding doc-section" : "col-sm-4 col-lg- no-padding" : void 0;
    }, $scope.logout = function() {
        AuthService.logout().then(function() {
            $window.location.href = "/login";
        });
    }, $scope.getDontDisturbModeClass = function() {
        switch (CurrentMember.dontDisturb.mode) {
          case CurrentMember.DONT_DISTURB_MODE.DEACTIVE:
            return "zmdi zmdi-notifications-active";

          case CurrentMember.DONT_DISTURB_MODE.ACTIVE:
            return "zmdi zmdi-notifications-off";

          case CurrentMember.DONT_DISTURB_MODE.TIMEACTIVE:
            return "zmdi zmdi-notifications-paused";
        }
    }, $scope.activateTimeDontDisturbMode = function(minute) {
        CurrentMember.activateTimeDontDisturbMode(6e4 * minute);
    }, $scope.activateDontDisturbMode = function() {
        CurrentMember.activateDontDisturbMode();
    }, $scope.deactivateDontDisturbMode = function() {
        CurrentMember.deactivateDontDisturbMode();
    }, $scope.getDontDisturbModeRemainingTime = function() {
        return CurrentMember.dontDisturb.remainingTime;
    }, $scope.setNotificationPermission = function() {
        "default" === $window.Notification.permission ? $window.Notification.requestPermission() : "denied" === $window.Notification.permission && $window.Notification.requestPermission();
    }, $scope.shouldShowNotificationPermission = function() {
        return "granted" !== $window.Notification.permission;
    }, $scope.navigateToHome = function() {
        $state.go("messenger.home");
    }, angular.element($window).bind("focus", function() {
        $rootScope.isTabFocused = !0, $rootScope.$broadcast("tab:focus:changed");
    }).bind("blur", function() {
        $rootScope.isTabFocused = !1, $rootScope.$broadcast("tab:focus:changed");
    }), angular.element($window).bind("focus", function() {
        $rootScope.isTabFocused = !0, $rootScope.$broadcast("tab:focus:changed");
    }).bind("blur", function() {
        $rootScope.isTabFocused = !1, $rootScope.$broadcast("tab:focus:changed");
    });
} ]), app.service("profileService", [ "$log", "Upload", "$http", "$q", "socket", "ArrayUtil", "AuthService", "$localStorage", "CurrentMember", "Team", function($log, Upload, $http, $q, socket, ArrayUtil, AuthService, $localStorage, CurrentMember, Team) {
    function changeUsername(username) {
        var defered = $q.defer();
        return $http({
            method: "PATCH",
            url: "/api/v1/auth/users/" + CurrentMember.member.user.id + "/username/change/",
            data: {
                username: username
            }
        }).then(function(data) {
            $localStorage.token = data.token, CurrentMember.username = username, ArrayUtil.getElementByKeyValue(Team.getActiveMembers(), "id", CurrentMember.member.id).username = username,
            AuthService.initialize(), defered.resolve("نام کاربری با موفقیت تغییر کرد.");
        }).catch(function(err) {
            $log.error("Error Changing Username", err), err.username ? ArrayUtil.contains(err.username, "This field may not be blank.") ? defered.reject("نام کاربری نباید خالی باشد.") : ArrayUtil.contains(err.username, "A user with that username already exists.") ? defered.reject("این نام کاربری قبلا انتخاب شده است.") : ArrayUtil.contains(err.username, "Enter a valid username. This value may contain only letters, numbers, and @/./+/-/_ characters.") ? defered.reject("نام کاربری معتبر نیست، این نام تنها می تواند شامل حروف، اعداد و بعضی از علامت ها باشد.") : defered.reject("خطا در تغییر نام کاربری") : defered.reject("خطا در تغییر نام کاربری");
        }), defered.promise;
    }
    function changePassword(oldPass, newPass, confirm) {
        var defered = $q.defer();
        return $http({
            method: "POST",
            url: "/api/v1/auth/password/change/",
            data: {
                old_password: oldPass,
                new_password1: newPass,
                new_password2: confirm
            }
        }).then(function(data) {
            defered.resolve("رمز عبور با موفقیت تغییر کرد.");
        }).catch(function(err) {
            $log.error("Error Changing Password", err), defered.reject("خطا در تغییر رمز عبور");
        }), defered.promise;
    }
    function changeProfileImage(file) {
        var defered = $q.defer();
        return Upload.upload({
            url: "/api/v1/auth/users/" + CurrentMember.member.user.id + "/image/change/",
            data: {
                image: file
            },
            method: "PATCH"
        }).then(function(res) {
            CurrentMember.member.image = res.data.image, defered.resolve("عکس پروفایل با موفقیت تغییر کرد.");
        }).catch(function(err) {
            $log.error("Error Changing Profile Image", err), defered.reject("خطا در تغییر عکس پروفایل");
        }), defered.promise;
    }
    function removeTeamMember(member) {
        var defered = $q.defer(), data = {
            memberId: member ? member.id : CurrentMember.member.id
        };
        return socket.emit("member:remove", data, function(res) {
            res.status ? defered.resolve() : ($log.error("Error :", res.message), defered.reject());
        }), defered.promise;
    }
    function makeAdmin(member) {
        var defered = $q.defer();
        return $http({
            method: "POST",
            url: "/api/v1/teams/" + Team.id + "/member/" + member.id + "/admin/"
        }).then(function() {
            defered.resolve();
        }).catch(function(err) {
            $log.error("Error Making Admin", err), defered.reject();
        }), defered.promise;
    }
    function disAdmin(member) {
        var defered = $q.defer();
        return $http({
            method: "POST",
            url: "/api/v1/teams/" + Team.id + "/member/" + member.id + "/disadmin/"
        }).then(function() {
            defered.resolve();
        }).catch(function(err) {
            $log.error("Error deAdmining", err), defered.reject();
        }), defered.promise;
    }
    function sendInvitationEmail(email) {
        return $http({
            method: "POST",
            url: "/api/v1/teams/" + Team.id + "/invite/send/",
            data: {
                email: email
            }
        });
    }
    return {
        changeUsername: changeUsername,
        changePassword: changePassword,
        changeProfileImage: changeProfileImage,
        removeTeamMember: removeTeamMember,
        makeAdmin: makeAdmin,
        disAdmin: disAdmin,
        sendInvitationEmail: sendInvitationEmail
    };
} ]), app.controller("teamProfileController", [ "$scope", "$log", "profileService", "$uibModalInstance", "CurrentMember", "Team", "$timeout", "validationUtil", "ArrayUtil", "teamService", "channelsService", "uiTourService", "tourClicked", function($scope, $log, profileService, $uibModalInstance, CurrentMember, Team, $timeout, validationUtil, ArrayUtil, teamService, channelsService, uiTourService, tourClicked) {
    function setInfoOrErrorMessage(type, message) {
        switch (type) {
          case "info":
            $scope.infoMessage = message, $scope.showInfoMessage = !0, $timeout(function() {
                $scope.showInfoMessage = !1, $scope.infoMessage = null;
            }, 4e3);
            break;

          case "error":
            $scope.showErrorMessage = !0, $scope.errorMessage = message, $timeout(function() {
                $scope.showErrorMessage = !1, $scope.errorMessage = null;
            }, 4e3);
        }
    }
    function initializeInviteMemberForm() {
        $scope.invitedEmail = "", $scope.forms.inviteMember.$setPristine();
    }
    !function() {
        $scope.teamMembers = Team.getActiveMembers(), $scope.team = Team, $scope.editTeamNameActive = !1,
        $scope.inviteMode = !1, $scope.forms = {};
    }(), $scope.$on("members:updated", function() {
        $scope.teamMembers = Team.getActiveMembers();
    }), $scope.inviteMember = function() {
        initializeInviteMemberForm(), $scope.inviteMode = !0;
    }, $scope.sendInvitation = function() {
        $scope.invitedEmail ? validationUtil.validateEmail($scope.invitedEmail) ? profileService.sendInvitationEmail($scope.invitedEmail).then(function() {
            $scope.invitedEmail = "", setInfoOrErrorMessage("info", "ایمیل دعوت به تیم با موفقیت ارسال شد."),
            $scope.inviteMode = !1;
        }).catch(function(err) {
            $log.error("Invitation Error:", err), err.data && "Email already a member." === err.data[0] ? setInfoOrErrorMessage("error", "فرد مورد نظرت در حال حاضر عضو تیمه") : err.data && "Email already has an active invitaion." === err.data[0] ? setInfoOrErrorMessage("error", "ایمیل فعال سازی ارسال شده است.") : setInfoOrErrorMessage("error", "خطا در دعوت به تیم");
        }) : setInfoOrErrorMessage("error", "ایمیل وارد شده معتبر نیست") : setInfoOrErrorMessage("error", "لطفا ایمیل رو وارد کن.");
    }, $scope.editTeamName = function() {
        $scope.editTeamNameActive = !0;
    }, $scope.saveTeamName = function() {
        $scope.editTeamNameActive = !1;
    }, $scope.removeTeamMember = function(member) {
        profileService.removeTeamMember(member);
    }, $scope.changeMemberAdminState = function(member) {
        !1 === member.isAdmin ? profileService.makeAdmin(member).then(function() {
            member.isAdmin = !0;
        }).catch(function(err) {
            $log.error("Error Making Member Admin:", err);
        }) : profileService.disAdmin(member).then(function() {
            member.isAdmin = !1;
        }).catch(function(err) {
            $log.error("Error DisAdmining Member:", err);
        });
    }, $scope.getAdminButtonCSS = function(member) {
        return member.isAdmin ? "is-admin" : "";
    }, $scope.onTourReady = function(tour) {
        tourClicked && $timeout(function() {
            tour.start();
        }, 500);
    }, $scope.isMe = function(member) {
        return member.id === CurrentMember.member.id;
    };
} ]), app.controller("userProfileController", [ "$scope", "$window", "CurrentMember", "AuthService", "profileService", "$uibModalInstance", "$timeout", function($scope, $window, CurrentMember, AuthService, profileService, $uibModalInstance, $timeout) {
    function setInfoOrErrorMessage(type, message) {
        switch (type) {
          case "info":
            $scope.infoMessage = message, $scope.showInfoMessage = !0, $timeout(function() {
                $scope.showInfoMessage = !1, $scope.infoMessage = null;
            }, 5e3);
            break;

          case "error":
            $scope.showErrorMessage = !0, $scope.errorMessage = message, $timeout(function() {
                $scope.showErrorMessage = !1, $scope.errorMessage = null;
            }, 5e3);
        }
    }
    function clearPasswordFields() {
        $scope.oldPasswordInput = "", $scope.newPasswordInput = "", $scope.confirmPasswordInput = "";
    }
    !function() {
        $scope.user = CurrentMember.member.user, $scope.usernameInput = "", $scope.editUsernameActive = !1,
        $scope.changePasswordActive = !1, $scope.showErrorMessage = !1, $scope.showInfoMessage = !1;
    }(), $scope.editUsername = function() {
        $scope.editUsernameActive = !0;
    }, $scope.changePassword = function() {
        clearPasswordFields(), $scope.changePasswordActive = !0;
    }, $scope.savePassword = function() {
        $scope.newPasswordInput !== $scope.confirmPasswordInput ? setInfoOrErrorMessage("error", "رمز عبور با تکرار آن مطابقت ندارد.") : ($scope.changePasswordActive = !1,
        profileService.changePassword($scope.oldPasswordInput, $scope.newPasswordInput, $scope.confirmPasswordInput).then(function(infoMsg) {
            setInfoOrErrorMessage("info", infoMsg);
        }).catch(function(errorMsg) {
            setInfoOrErrorMessage("error", errorMsg);
        }));
    }, $scope.saveUsername = function() {
        "" === $scope.usernameInput ? setInfoOrErrorMessage("error", "نام کاربری نباید خالی باشد.") : $scope.usernameInput.length > 16 ? setInfoOrErrorMessage("error", "نام کاربری حداکثر می تواند ۱۶ کاراکتر باشد.") : profileService.changeUsername($scope.usernameInput).then(function(infoMsg) {
            $scope.user.username = $scope.usernameInput, setInfoOrErrorMessage("info", infoMsg),
            $scope.editUsernameActive = !1;
        }).catch(function(errorMsg) {
            setInfoOrErrorMessage("error", errorMsg), $scope.usernameInput = "";
        });
    }, $scope.uploadProfileImage = function(file, errorFiles) {
        file && profileService.changeProfileImage(file).then(function(infoMsg) {
            setInfoOrErrorMessage("info", infoMsg);
        }).catch(function(errorMsg) {
            setInfoOrErrorMessage("error", errorMsg);
        });
    }, $scope.leaveTeam = function() {
        profileService.removeTeamMember().then(function() {
            return AuthService.logout();
        }).then(function() {
            $window.location.href = "/login";
        });
    };
} ]), app.factory("AuthService", [ "$log", "$http", "$q", "$window", "$timeout", "$localStorage", "jwtHelper", "ArrayUtil", "CurrentMember", "$injector", "domainUtil", "validationUtil", "$rootElement", function($log, $http, $q, $window, $timeout, $localStorage, jwtHelper, ArrayUtil, CurrentMember, $injector, domainUtil, validationUtil, $rootElement) {
    function initialize() {
        createUser($localStorage.token, domainUtil.getSubdomain());
    }
    function createUser(token, teamSlug) {
        var decodedToken = jwtHelper.decodeToken(token), currentMembership = ArrayUtil.getElementByKeyValue(decodedToken.memberships, "team_slug", teamSlug);
        CurrentMember.initialize(currentMembership.id, currentMembership.is_admin, decodedToken.user_id, decodedToken.username, decodedToken.email, decodedToken.image),
        Team.initialize(currentMembership.team_id);
    }
    function persistToken(token) {
        $localStorage.token = token;
    }
    function login(usernameOrEmail, password) {
        var defer = $q.defer(), data = {
            password: password,
            teamSlug: domainUtil.getSubdomain()
        };
        return validationUtil.validateEmail(usernameOrEmail) ? data.email = usernameOrEmail : data.username = usernameOrEmail,
        $http({
            method: "POST",
            url: "/api/v1/auth/login/",
            data: data,
            skipAuthorization: !0
        }).then(function(response) {
            var token = response.data.token;
            token ? (persistToken(token), defer.resolve()) : defer.reject();
        }).catch(function(err) {
            defer.reject(err);
        }), defer.promise;
    }
    function logout() {
        var defer = $q.defer();
        return $http.post("/api/v1/auth/logout/").then(function(res) {
            $log.info(res), defer.resolve();
        }).catch(function(err) {
            $log.info("Logout error.", err), defer.reject();
        }), defer.promise;
    }
    var Team;
    return "tecomApp" === $rootElement.attr("ng-app") && (Team = $injector.get("Team"),
    initialize()), {
        initialize: initialize,
        createUser: createUser,
        login: login,
        logout: logout
    };
} ]), app.factory("CurrentMember", [ "Member", "$localStorage", "$timeout", "textUtil", "$interval", function(Member, $localStorage, $timeout, textUtil, $interval) {
    function CurrentMember() {}
    return CurrentMember.initialize = function(id, isAdmin, userId, username, email, image) {
        CurrentMember.member = new Member(id, isAdmin, userId, username, email, image, Member.STATUS.ONLINE);
    }, CurrentMember.exists = function() {
        return !!CurrentMember.member;
    }, CurrentMember.initializeDontDisturbMode = function() {
        if (CurrentMember.dontDisturb = {}, $localStorage.dontDisturb) {
            var duration = $localStorage.dontDisturb.duration;
            duration ? CurrentMember.checkShouldContinueTimeActive(duration) : CurrentMember.dontDisturb.mode = $localStorage.dontDisturb.mode;
        } else CurrentMember.initializeInitialJsons();
    }, CurrentMember.initializeInitialJsons = function() {
        var initMode = {
            mode: CurrentMember.DONT_DISTURB_MODE.DEACTIVE
        };
        $localStorage.dontDisturb = initMode, CurrentMember.dontDisturb.mode = $localStorage.dontDisturb.mode;
    }, CurrentMember.checkShouldContinueTimeActive = function(duration) {
        var initTime = +new Date(), startTime = $localStorage.dontDisturb.startTime;
        initTime - startTime < duration ? CurrentMember.activateTimeDontDisturbMode(startTime + duration - initTime) : (CurrentMember.removeDontDisturbModeTimeProperties(),
        CurrentMember.setDontDisturbMode(CurrentMember.DONT_DISTURB_MODE.DEACTIVE));
    }, CurrentMember.setDontDisturbMode = function(mode) {
        $localStorage.dontDisturb.mode = mode, CurrentMember.dontDisturb.mode = mode;
    }, CurrentMember.activateTimeDontDisturbMode = function(miliseconds) {
        CurrentMember.setDontDisturbModeTimeProperties(miliseconds), CurrentMember.setDontDisturbMode(CurrentMember.DONT_DISTURB_MODE.TIMEACTIVE),
        CurrentMember.setDontDisturbTimeout(miliseconds), CurrentMember.dontDisturbInterval = $interval(function() {
            CurrentMember.updateDontDisturbRemainingTime();
        }, 1e3);
    }, CurrentMember.activateDontDisturbMode = function() {
        CurrentMember.dontDisturb.mode === CurrentMember.DONT_DISTURB_MODE.TIMEACTIVE && (CurrentMember.removeDontDisturbModeTimeProperties(),
        $timeout.cancel(CurrentMember.dontDisturbTimeout), CurrentMember.removeDontDisturbModeRemainingTime()),
        CurrentMember.setDontDisturbMode(CurrentMember.DONT_DISTURB_MODE.ACTIVE);
    }, CurrentMember.deactivateDontDisturbMode = function() {
        CurrentMember.dontDisturb.mode === CurrentMember.DONT_DISTURB_MODE.TIMEACTIVE && (CurrentMember.removeDontDisturbModeTimeProperties(),
        $timeout.cancel(CurrentMember.dontDisturbTimeout), CurrentMember.removeDontDisturbModeRemainingTime()),
        CurrentMember.setDontDisturbMode(CurrentMember.DONT_DISTURB_MODE.DEACTIVE);
    }, CurrentMember.setDontDisturbModeTimeProperties = function(duration) {
        var startTime = +new Date();
        CurrentMember.dontDisturb.duration = duration, $localStorage.dontDisturb.duration = duration,
        CurrentMember.dontDisturb.startTime = startTime, $localStorage.dontDisturb.startTime = startTime;
    }, CurrentMember.removeDontDisturbModeTimeProperties = function() {
        delete $localStorage.dontDisturb.duration, CurrentMember.dontDisturb.duration = null,
        delete $localStorage.dontDisturb.startTime, CurrentMember.dontDisturb.startTime = null;
    }, CurrentMember.removeDontDisturbModeRemainingTime = function() {
        $interval.cancel(CurrentMember.dontDisturbInterval), CurrentMember.dontDisturb.remainingTime = null;
    }, CurrentMember.setDontDisturbTimeout = function(duration) {
        CurrentMember.dontDisturbTimeout = $timeout(function() {
            CurrentMember.removeDontDisturbModeTimeProperties(), CurrentMember.setDontDisturbMode(CurrentMember.DONT_DISTURB_MODE.DEACTIVE),
            $interval.cancel(CurrentMember.dontDisturbInterval);
        }, duration);
    }, CurrentMember.isDontDisturbModeActive = function() {
        return CurrentMember.dontDisturb.mode === CurrentMember.DONT_DISTURB_MODE.ACTIVE;
    }, CurrentMember.isDontDisturbModeDeactive = function() {
        return CurrentMember.dontDisturb.mode === CurrentMember.DONT_DISTURB_MODE.DEACTIVE;
    }, CurrentMember.isDontDisturbModeTimeActive = function() {
        return CurrentMember.dontDisturb.mode === CurrentMember.DONT_DISTURB_MODE.TIMEACTIVE;
    }, CurrentMember.updateDontDisturbRemainingTime = function() {
        CurrentMember.dontDisturb.remainingTime = CurrentMember.getLocaleDontDisturbRemainingTime();
    }, CurrentMember.getLocaleDontDisturbRemainingTime = function() {
        var remainingSeconds = (CurrentMember.dontDisturb.duration + CurrentMember.dontDisturb.startTime - +new Date()) / 1e3, minutes = Math.floor(remainingSeconds / 60), seconds = Math.floor(remainingSeconds % 60);
        return textUtil.persianify(seconds.toString() + " : " + minutes.toString());
    }, CurrentMember.DONT_DISTURB_MODE = {
        DEACTIVE: 0,
        ACTIVE: 1,
        TIMEACTIVE: 2
    }, CurrentMember;
} ]), app.factory("Member", [ "User", function(User) {
    function Member(teamMemberId, isAdmin, userId, username, email, image, status) {
        this.id = teamMemberId, this.isAdmin = isAdmin, this.user = new User(userId, username, email, image),
        this.status = status;
    }
    return Member.prototype.isTecomBot = function() {
        return this.id === Member.TECOM_BOT.id;
    }, Member.prototype.isActive = function() {
        return this.status !== Member.STATUS.DEACTIVE;
    }, Member.TECOM_BOT = {
        id: 0,
        username: "تیک-بات"
    }, Member.STATUS = {
        OFFLINE: 0,
        ONLINE: 1,
        DEACTIVE: 2
    }, Member;
} ]), app.factory("Team", [ "$http", "socket", "$q", "$log", "$localStorage", "ArrayUtil", "Member", function($http, socket, $q, $log, $localStorage, ArrayUtil, Member) {
    function Team() {}
    return Team.initialize = function(id) {
        Team.id = id, Team.members = [], Team.membersPromise = Team.getTeamMembers(), Team.getName().then(function(res) {
            Team._name = res.name;
        });
    }, Team.getTeamMembers = function() {
        var deferred = $q.defer();
        return socket.emit("team:members", null, function(res) {
            Team.members = res.map(function(memberData) {
                return new Member(memberData.id, memberData.isAdmin, memberData.user_id, memberData.username, memberData.email, memberData.image, memberData.status);
            }), deferred.resolve();
        }), deferred.promise;
    }, Team.getName = function() {
        return $http({
            method: "GET",
            url: "/api/v1/teams/" + Team.id + "/name/",
            headers: {
                Authorization: "JWT " + $localStorage.token
            }
        });
    }, Team.getUsernameByMemberId = function(memberId) {
        if (memberId === Member.TECOM_BOT.id) return Member.TECOM_BOT.username;
        var member = ArrayUtil.getElementByKeyValue(Team.members, "id", memberId);
        return member ? member.user.username : "";
    }, Team.getMemberByUsername = function(username) {
        if (username === Member.TECOM_BOT.username) return Member.TECOM_BOT;
        var member = ArrayUtil.getElementByKeyValue(Team.members, "user.username", username);
        return member || ($log.error("Member Not Found !"), null);
    }, Team.getMemberByMemberId = function(memberId) {
        if (memberId === Member.TECOM_BOT.id) return Member.TECOM_BOT;
        var member = ArrayUtil.getElementByKeyValue(Team.members, "id", memberId);
        return member || $log.error("Member Not Found !"), member;
    }, Team.getActiveMembers = function() {
        return Team.members.filter(function(member) {
            return member.isActive();
        });
    }, Team.isMemberActiveByUsername = function(username) {
        var member = Team.getMemberByUsername(username);
        return !!member && (member.id === Member.TECOM_BOT.id || member.isActive());
    }, Team.getImageByMemberId = function(memberId) {
        return Team.getMemberByMemberId(memberId).image;
    }, Team;
} ]), app.factory("teamService", [ "$rootScope", "$window", "socket", "Team", "ArrayUtil", "channelsService", "AuthService", "Channel", "Member", "CurrentMember", function($rootScope, $window, socket, Team, ArrayUtil, channelsService, AuthService, Channel, Member, CurrentMember) {
    function deactiveTeamMember(memberId) {
        var member = Team.getMemberByMemberId(memberId);
        member && (member.status = Member.STATUS.DEACTIVE);
    }
    return socket.on("member:new", function(memberData) {
        var member = new Member(memberData.id, memberData.isAdmin, memberData.user_id, memberData.username, memberData.email, memberData.image, Member.STATUS.ONLINE);
        Team.members.push(member), channelsService.createAndPushChannel({
            name: member.user.username,
            slug: member.user.username,
            type: Channel.TYPE.DIRECT,
            memberId: member.id,
            isFakeDirect: !0
        }), $rootScope.$broadcast("channels:updated");
    }), socket.on("member:remove", function(memberId) {
        if (memberId === CurrentMember.member.id) AuthService.logout().then(function() {
            $window.location.assign("/login?err=UserRemoved");
        }); else {
            deactiveTeamMember(memberId);
            var username = Team.getUsernameByMemberId(memberId);
            channelsService.setDirectActiveState(username, !1), $rootScope.$broadcast("channels:updated"),
            $rootScope.$broadcast("members:updated");
        }
    }), socket.on("member:status:change", function(data) {
        Team.getMemberByMemberId(data.memberId).status = data.status;
    }), {
        deactiveTeamMember: deactiveTeamMember
    };
} ]).run([ "teamService", function(teamService) {} ]), app.factory("User", function() {
    function User(id, username, email, image) {
        this.id = id, this.username = username, this.email = email, this.image = image || "/static/img/user-def.png",
        this.usernameColor = "#" + (16777215 * Math.random() << 0).toString(16);
    }
    return User;
}), app.service("db", [ "$window", "$q", "$log", "CurrentMember", "Team", function($window, $q, $log, CurrentMember, Team) {
    function getDb() {
        var deferred = $q.defer();
        return self.isIndexReady ? deferred.resolve(self.db) : self.createIndexPromise.then(function() {
            deferred.resolve(self.db), self.isIndexReady = !0;
        }), deferred.promise;
    }
    function destroy() {
        self.db.destroy().then(function(response) {
            $log.info("Database cleared succesfully.");
        }).catch(function(err) {
            $log.error("Error clearing database.", err);
        });
    }
    var self = this;
    if (CurrentMember.exists()) return function() {
        self.db = new $window.PouchDB("tecom:" + Team.id + ":" + CurrentMember.member.id),
        $log.info("PouchDB connected successfuly."), self.createIndexPromise = self.db.createIndex({
            index: {
                fields: [ "id", "channelId" ]
            }
        });
    }(), {
        getDb: getDb,
        destroy: destroy
    };
} ]), app.directive("compile", [ "$compile", function($compile) {
    return {
        scope: !0,
        link: function(scope, element, attrs) {
            attrs.$observe("template", function(template) {
                if (angular.isDefined(template)) {
                    template = "<div>" + template + "</div>";
                    var compiled = $compile(template)(scope);
                    element.html(""), element.append(compiled);
                }
            });
        }
    };
} ]), app.directive("confirmDialog", function() {
    function getTemplate(element, attrs) {
        var elementName = attrs.isAnchor ? "a" : "button", templateString = "<" + elementName + ' class="{{class}}" mwl-confirm message="{{message}}" confirm-text="{{ok}}"  animation="true" cancel-text="{{cancel}}" placement="bottom"  on-confirm="callUpdate()" confirm-button-type="{{confirmButton}}"  cancel-button-type="default">';
        return attrs.icon ? templateString += '<span class="{{icon}}"></span>' : templateString += "{{buttonName}}",
        templateString += "</" + elementName + ">";
    }
    return {
        scope: {
            class: "@",
            icon: "@",
            buttonName: "@",
            message: "@",
            cancel: "@",
            ok: "@",
            confirmButton: "@",
            isAnchor: "@",
            confirmFunc: "&",
            args: "="
        },
        replace: !0,
        template: getTemplate,
        link: function(scope, elm, attrs) {
            scope.callUpdate = function() {
                var fn = scope.confirmFunc();
                scope.args ? fn.apply(null, scope.args) : fn();
            };
        }
    };
}), app.run([ "$window", "$exceptionHandler", function($window, $exceptionHandler) {
    $window.onerror = function(message, url, line, col, error) {
        error || (error = new Error(message)), $exceptionHandler(error);
    };
} ]), app.config([ "$provide", function($provide) {
    $provide.decorator("$exceptionHandler", [ "$delegate", "$injector", function($delegate, $injector) {
        return function(exception, cause) {
            $delegate(exception, cause);
            var $http = $injector.get("$http"), $log = $injector.get("$log"), CurrentMember = $injector.get("CurrentMember"), error = {
                message: exception.message,
                stacktrace: exception.stack,
                user_agent: window.navigator.userAgent
            };
            CurrentMember.exists() && (error.member = CurrentMember.member.id), $http.post("/api/v1/logs/create/", error).then(function() {
                $log.info("Error log sent to server successfully. We will fix it soon.");
            }).catch(function() {
                $log.error("Error sending error log to server");
            });
        };
    } ]);
} ]), app.factory("authInterceptor", [ "$q", "$log", "$localStorage", "$window", function($q, $log, $localStorage, $window) {
    return {
        responseError: function(rejection) {
            switch ($log.error("Http response error. Rejection status:", rejection.status),
            rejection.status) {
              case 401:
                $localStorage.token = null, $window.location.assign("/login?err=InvalidToken");
            }
            return $q.reject(rejection);
        }
    };
} ]).config([ "$httpProvider", function($httpProvider) {
    $httpProvider.interceptors.push("authInterceptor");
} ]), app.factory("socket", [ "$rootScope", "$log", "ENV", "$uibModal", "domainUtil", "$localStorage", function($rootScope, $log, ENV, $uibModal, domainUtil, $localStorage) {
    var self = this, teamSlug = domainUtil.getSubdomain();
    return self.socket = io.connect(ENV.socketUri, {
        path: "/",
        query: {
            token: $localStorage.token,
            teamSlug: teamSlug
        },
        extraHeaders: {
            Connection: "keep-alive"
        }
    }), self.socket.on("connect", function() {
        $log.info("Socket opened and connection established successfuly."), $rootScope.socketConnected = !0,
        $rootScope.$broadcast("socket:connected");
    }), self.socket.on("disconnect", function() {
        $log.error("Socket disconnected."), $rootScope.socketConnected = !1;
    }), self.socket.on("err", function(err) {
        $log.info("Error On Socket :", err);
    }), {
        on: function(eventName, callback) {
            self.socket.on(eventName, function() {
                var args = arguments;
                $rootScope.$apply(function() {
                    callback.apply(self.socket, args);
                });
            });
        },
        emit: function(eventName, data, callback) {
            self.socket.emit(eventName, data, function() {
                var args = arguments;
                $rootScope.$apply(function() {
                    callback && callback.apply(self.socket, args);
                });
            });
        }
    };
} ]), app.factory("ArrayUtil", function() {
    function getIndexByKeyValue(array, key, value) {
        for (var keySplit = key.split("."), i = 0; i < array.length; i++) {
            for (var temp = array[i], k = 0; k < keySplit.length; k++) temp = temp[keySplit[k]];
            if (temp == value) return i;
        }
        return -1;
    }
    function getIndexByValue(array, value) {
        for (var i = 0; i < array.length; i++) if (array[i] == value) return i;
        return -1;
    }
    function getElementByKeyValue(array, key, value) {
        var index = getIndexByKeyValue(array, key, value);
        return -1 === index ? null : array[index];
    }
    function getLastElement(array) {
        return 0 === array.length ? null : array[array.length - 1];
    }
    function removeElementByIndex(array, index) {
        index > -1 && array.splice(index, 1);
    }
    function removeElementByKeyValue(array, key, value) {
        var index = getIndexByKeyValue(array, key, value);
        index > -1 && array.splice(index, 1);
    }
    function removeElementByValue(array, value) {
        var index = getIndexByValue(array, value);
        index > -1 && array.splice(index, 1);
    }
    function contains(array, value) {
        return array.indexOf(value) > -1;
    }
    function containsKeyValue(array, key, value) {
        return getIndexByKeyValue(array, key, value) > -1;
    }
    function sortByKeyDesc(array, key) {
        array.sort(function(a, b) {
            return a[key] < b[key] ? 1 : a[key] > b[key] ? -1 : 0;
        });
    }
    return {
        getIndexByKeyValue: getIndexByKeyValue,
        getIndexByValue: getIndexByValue,
        getElementByKeyValue: getElementByKeyValue,
        getLastElement: getLastElement,
        removeElementByIndex: removeElementByIndex,
        removeElementByKeyValue: removeElementByKeyValue,
        contains: contains,
        containsKeyValue: containsKeyValue,
        removeElementByValue: removeElementByValue,
        sortByKeyDesc: sortByKeyDesc
    };
}), app.factory("dateUtil", [ "$window", function($window) {
    function getPersianDateString(datetime) {
        return $window.persianDate(datetime).format("dddd DD MMMM");
    }
    function getPersianTime(datetime) {
        return $window.persianDate(datetime).format("h:mm");
    }
    return {
        getPersianDateString: getPersianDateString,
        getPersianTime: getPersianTime
    };
} ]), app.factory("domainUtil", [ "$location", function($location) {
    function getSubdomain() {
        var host = $location.host();
        return host.indexOf(".") < 0 ? "" : host.split(".")[0];
    }
    return {
        getSubdomain: getSubdomain
    };
} ]), app.factory("fileUtil", [ "ArrayUtil", function(ArrayUtil) {
    function isTextFormat(format) {
        return ArrayUtil.contains(textBaseFormats, format);
    }
    function isPictureFormat(format) {
        return ArrayUtil.contains(pictureFormats, format);
    }
    function fileManagerFileFormat(format) {
        return ArrayUtil.contains(textBaseFormats, format) ? 1 : ArrayUtil.contains(pictureFormats, format) ? 2 : ArrayUtil.contains(documentFormats, format) ? 3 : 4;
    }
    var textBaseFormats = [ "txt", "c", "js", "java", "py", "cpp", "css", "apsx", "htm", "jsp", "php", "xml", "asp", "rdf", "cs", "fs", "lib", "s", "src", "dtd", "bat", "o", "mm", "swift", "cc", "lua", "prl", "mac", "phtml", "sh", "h", "html5", "cxx", "vb", "r", "cls", "pyt", "cmd", "rb", "p", "php3", "cbl", "perl", "f", "dtx", "sub", "ptl", "ksf", "dsd", "mak", "scpt", "less", "run", "cp", "m", "obj", "lpx", "ascx", "coffee", "script", "rh", "jade", "j", "jav", "xtx", "c#", "f#", "f95", "mf", "devpak", "f90", "phps", "ruby", "command", "jcs", "scala", "for", "bsh", "c++", "dfn", "php2", "iml", "php5", "hc", "make", "vim", "ogr", "sass", "cuh", "vc6", "cobol", "rdoc", "sql", "rub", "playground", "phs", "pdr", "xib", "vbscript", "rc3", "php1", "hxx", "d", "proto", "asp+", "snippet", "cu", "applescript", "git", "ijs", "ftn", "pbp", "cfo", "map", "rb", "xpdl", "vmx", "common", "go", "login", "udf", "a", "sbs", "chh", "phpt", "gemfile", "class", "pp", "hh", "b", "mst", "cola", "zsh", "ahtml", "rex", "mod", "has", "w", "reb", "msc", "rake", "tcsh", "tql", "erl", "hpp", "gml", "rbx", "mli", "pdl", "pxi", "simba", "xmljet", "fpp", "pdl", "gs", "rs", "magik", "cr2", "gst", "con", "sit", "qf", "gnumakefile", "fdo", "epp", "emakefile", "sw", "ks", "m2", "pm6", "p5", "adiumscripts", "eql", "lit", "xmss", "seestyle", "makefile", "sjava", "emakerfile", "cuo", "rtf", "es6", "hbs", "erb", "scss" ], pictureFormats = [ "ani", "bmp", "cal", "eps", "fax", "gif", "img", "jbg", "jpe", "jpeg", "jpg", "mac", "pbm", "pcd", "pcx", "pct", "pgm", "png", "ppm", "psd", "ras", "tga", "tiff", "wmf" ], documentFormats = [ "pdf", "doc", "docx", "xls", "xlsx", "ppt", "pptx", "odx", "txt", "rtf" ];
    return {
        isTextFormat: isTextFormat,
        isPictureFormat: isPictureFormat,
        fileManagerFileFormat: fileManagerFileFormat
    };
} ]), app.factory("textUtil", function() {
    function isEnglish(text) {
        if (!text) return !1;
        var english = /^[a-zA-Z0-9.?><\/\\:;,{}()$[\]\-_+=!@#$%\^&*|'"` ]*$/, isEnglish = !0;
        return text.split(" ").forEach(function(word) {
            isEnglish = isEnglish && english.test(word);
        }), isEnglish;
    }
    function htmlify(text) {
        for (var wellFormedText = "", isUrlifyTurn = !0, textParts = text.split("`"), i = 0; i < textParts.length - 1; i++) wellFormedText += isUrlifyTurn ? urlify(directionify(textParts[i])) : codify(textParts[i]),
        isUrlifyTurn = !isUrlifyTurn;
        return wellFormedText += urlify(directionify(textParts[textParts.length - 1]));
    }
    function urlify(text) {
        var urlRegex = /[-a-zA-Z0-9@:%_\+.~#?&\/\/=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#\?&\/\/=]*)?/gi;
        return text.replace(urlRegex, function(url) {
            if (validUrl(url)) {
                var href = url;
                return -1 === url.indexOf("//") && (href = "//" + url), '<a href="' + href + '" target="_blank">' + url + "</a>";
            }
            return url;
        });
    }
    function validUrl(url) {
        var tld = [ "com", "ir", "net", "org", "biz", "info", "name", "me", "ws", "us", "tv", "gov", "co", "edu", "asia", "int", "tel", "mil", "coop", "io", "jobs", "mobi", "pro" ];
        url = url.split("."), url = url[url.length - 1];
        for (var i = 0; i < tld.length; i++) if (url.substring(0, tld[i].length) === tld[i]) return !0;
        return !1;
    }
    function codify(text) {
        return '<code class="msg-inline-code" dir="ltr">' + text + "</code>";
    }
    function directionify(text) {
        if (!/\b((?!=|\,|\.).)+(.)\b/.test(text)) return text;
        var directionRegex = /([^\u0600-\u065F\u066E-\u06D5]+)/g;
        return text.replace(directionRegex, function(englishPart) {
            if (" " === englishPart) return englishPart;
            var hasFirstSpace = " " === englishPart[0], hasLastSpace = " " === englishPart[englishPart.length - 1];
            return (hasFirstSpace ? " " : "") + '<span style="direction:ltr" dir="ltr">' + englishPart.trim() + "</span> " + (hasLastSpace ? " " : "");
        });
    }
    function hashtagify(text) {
        var hashtagRegex = /(^|\W)(#[a-z\d][\w-]*)/gi;
        return text.replace(hashtagRegex, '$1<a href="/$2">$2</a>');
    }
    function persianify(text) {
        var persian = {
            0: "۰",
            1: "۱",
            2: "۲",
            3: "۳",
            4: "۴",
            5: "۵",
            6: "۶",
            7: "۷",
            8: "۸",
            9: "۹"
        }, list = text.match(/[0-9]/g);
        if (null !== list && 0 !== list.length) for (var i = 0; i < list.length; i++) text = text.replace(list[i], persian[list[i]]);
        return text;
    }
    function htmlToPlaintext(text) {
        var plainText = text.replace(/</g, "&lt");
        return plainText = plainText.replace(/>/g, "&gt"), plainText = plainText.replace(/{/g, "&#123;&zwnj;"),
        plainText = plainText.replace(/}/g, "&zwnj;&#125;");
    }
    return {
        isEnglish: isEnglish,
        htmlify: htmlify,
        hashtagify: hashtagify,
        persianify: persianify,
        htmlToPlaintext: htmlToPlaintext
    };
}), app.factory("validationUtil", function() {
    function validateEmail(email) {
        return /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(email);
    }
    return {
        validateEmail: validateEmail
    };
});
